<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <title>타이포 메이커</title>
        <!-- Google Fonts -->
        <link
            href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=D2+Coding&display=swap"
            rel="stylesheet"
        />
        <!-- Font Awesome -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        />
        <style>
            /* 추가: 드래그 시 텍스트 선택 금지를 위한 클래스 */
            .no-select {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            @font-face {
                font-family: "나눔바른펜";
                src: url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumBarunpen/NanumBarunpenRegular.woff2")
                        format("woff2"),
                    url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumBarunpen/NanumBarunpenRegular.woff")
                        format("woff");
            }

            @font-face {
                font-family: "나눔손글씨";
                src: url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumBrush/NanumBrush.woff2")
                        format("woff2"),
                    url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumBrush/NanumBrush.woff")
                        format("woff");
            }

            @font-face {
                font-family: "나눔스퀘어라운드";
                src: url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumSquareRound/NanumSquareRoundR.woff2")
                        format("woff2"),
                    url("https://hangeul.pstatic.net/hangeul_static/webfont/NanumSquareRound/NanumSquareRoundR.woff")
                        format("woff");
            }

            @font-face {
                font-family: "마루 부리";
                src: url("https://hangeul.pstatic.net/hangeul_static/webfont/MaruBuri/MaruBuri-Regular.woff2")
                        format("woff2"),
                    url("https://hangeul.pstatic.net/hangeul_static/webfont/MaruBuri/MaruBuri-Regular.woff")
                        format("woff");
            }

            @font-face {
                font-family: "본고딕";
                src: url("https://github.com/adobe-fonts/source-han-sans/raw/release/WOFF2/OTF/SourceHanSansK-Regular.woff2")
                        format("woff2"),
                    url("https://github.com/adobe-fonts/source-han-sans/raw/release/WOFF/OTF/SourceHanSansK-Regular.woff")
                        format("woff");
            }

            @font-face {
                font-family: "잘난체";
                src: url("https://cdn.jsdelivr.net/gh/webfontworld/jalnan/Jalnan.woff2")
                        format("woff2"),
                    url("https://cdn.jsdelivr.net/gh/webfontworld/jalnan/Jalnan.woff")
                        format("woff");
            }

            @font-face {
                font-family: "디자인하우스체";
                src: url("https://www.designhouse.co.kr/upload/font/DesignhouseFont.woff2")
                        format("woff2"),
                    url("https://www.designhouse.co.kr/upload/font/DesignhouseFont.woff")
                        format("woff");
            }

            @font-face {
                font-family: "둥근모꼴체";
                src: url("https://cdn.jsdelivr.net/gh/projectnoonnu/dunggeunmo/DungGeunMo.woff2")
                        format("woff2"),
                    url("https://cdn.jsdelivr.net/gh/projectnoonnu/dunggeunmo/DungGeunMo.woff")
                        format("woff");
            }

            @font-face {
                font-family: "어비마이센체";
                src: url("https://uhbeefont.com/uhbee_mycen/UhBeeMycen.woff2")
                        format("woff2"),
                    url("https://uhbeefont.com/uhbee_mycen/UhBeeMycen.woff")
                        format("woff");
            }

            /* 기본 초기화 */
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            html,
            body {
                width: 100%;
                height: 100%;
                background-color: #232323;
                color: #ccc;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
                    "Helvetica Neue", sans-serif;
                overflow: hidden;
            }

            /* 상단 메뉴 */
            .top-menu {
                display: flex;
                align-items: center;
                height: 40px;
                background-color: #333;
                padding: 0 16px;
                flex-shrink: 0;
            }

            .logo {
                font-weight: 700;
                font-size: 1.1rem;
                margin-right: 64px;
            }

            .menu-item {
                margin-right: 16px;
                cursor: pointer;
                user-select: none;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .menu-item:hover {
                color: #fff;
            }

            .preview-bg-item label {
                cursor: pointer;
            }

            /* 메인 컨테이너 */
            .main-container {
                display: flex;
                height: calc(100vh - 40px);
                overflow: hidden;
                min-height: 0;
            }

            #resizer {
                width: 5px;
                cursor: col-resize;
                background-color: rgba(255, 255, 255, 0.1);
                height: 100%;
                z-index: 1050;
            }

            .center-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                min-height: 0;
            }

            /* 프리뷰 영역 */
            .preview-container {
                background-color: #111;
                border-bottom: 1px solid #333;
                display: flex;
                flex-direction: column;
                align-items: center;
                height: 50vh;
                overflow: auto;
            }

            .preview {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: #000;
            }

            .preview-content {
                height: 100%;
                width: auto;
                max-width: 100%;
                aspect-ratio: 16 / 9;
                position: relative;
                overflow: hidden;
                border: 3px solid #fff;
            }

            .preview-text {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                color: #fff;
                pointer-events: none;
                white-space: nowrap;
                padding: 2px 4px;
            }

            /* 사각형, 동그라미 미리보기 – 중앙 정렬 */
            .preview-rect,
            .preview-circle {
                position: absolute;
                left: 50%;
                top: 50%;
            }

            /* 전체 채우기 미리보기 – 전 영역을 덮도록 */
            .preview-fill {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }

            .player-controls {
                display: flex;
                align-items: center;
                gap: 8px;
                margin: 8px 0;
            }

            .player-controls button {
                width: 32px;
                height: 32px;
                background-color: #444;
                border: none;
                border-radius: 4px;
                color: #fff;
                cursor: pointer;
            }

            .player-controls button:hover {
                background-color: #666;
            }

            .player-controls svg {
                width: 16px;
                height: 16px;
            }

            /* 볼륨 컨트롤 슬라이더 */
            #bgVolumeControl {
                width: 80px;
                margin-right: 64px;
            }

            #currentTimeLabel {
                min-width: 40px;
                text-align: center;
            }

            /* 음원 파일명 표시 */
            #bgMusicFileName {
                font-size: 0.9rem;
                margin-right: 16px;
            }

            /* 타임라인 영역 */
            .timeline-area {
                background-color: #333;
                display: flex;
                flex-direction: column;
                border-top: 1px solid #444;
                flex: 1;
                overflow: hidden;
                position: relative;
            }

            .timeline-header {
                position: relative;
                z-index: 1100;
                height: 32px;
                display: flex;
                align-items: center;
                background-color: #3a3a3a;
                padding: 0 8px;
                border-bottom: 1px solid #444;
                gap: 8px;
            }

            .timeline-header button {
                padding: 4px 8px;
                background-color: #5a5a5a;
                color: #fff;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .timeline-header button:hover {
                background-color: #777;
            }

            .track-label {
                font-weight: 500;
                margin-left: auto;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .timeline-header label {
                margin-left: auto;
                color: #ccc;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            #timeIndicator {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                width: 10px;
                cursor: pointer;
                z-index: 1000;
                background: transparent;
            }

            #timeIndicator::before {
                content: "";
                position: absolute;
                left: 4px;
                top: 0;
                bottom: 0;
                width: 2px;
                background-color: red;
            }

            .track {
                position: relative;
                height: 60px;
                border-bottom: 1px solid #444;
                width: calc(300 * 50px);
                margin-bottom: 4px;
                background-color: #2c2c2c;
            }

            .track-context-menu {
                position: absolute;
                background-color: #444;
                border: 1px solid #666;
                padding: 4px;
                display: none;
                z-index: 9999;
            }

            .track-context-menu div {
                padding: 4px 12px;
                cursor: pointer;
            }

            .track-context-menu div:hover {
                background-color: #555;
            }

            .clip {
                position: absolute;
                top: 10px;
                height: 40px;
                background-color: #6a6ad8;
                border-radius: 4px;
                color: #fff;
                font-size: 0.8rem;
                display: flex;
                align-items: center;
                justify-content: center;
                user-select: none;
                cursor: move;
            }

            .clip.selected {
                outline: 2px solid #ffcc00;
            }

            .clip-label {
                padding: 0 6px;
                flex: 1;
                text-align: center;
            }

            .clip-handle-r {
                position: absolute;
                top: 0;
                right: 0;
                width: 6px;
                height: 100%;
                background-color: #aaa;
                cursor: ew-resize;
            }

            .clip-handle-l {
                position: absolute;
                top: 0;
                left: 0;
                width: 6px;
                height: 100%;
                background-color: #aaa;
                cursor: ew-resize;
            }

            /* 클립 우클릭 삭제용 컨텍스트 메뉴 */
            .clip-context-menu {
                position: absolute;
                background-color: #444;
                border: 1px solid #666;
                padding: 4px;
                z-index: 9999;
            }

            .clip-context-menu div {
                padding: 4px 12px;
                cursor: pointer;
            }

            .clip-context-menu div:hover {
                background-color: #555;
            }

            .right-panel {
                width: 420px;
                max-width: 600px;
                background-color: #2c2c2c;
                display: flex;
                flex-direction: column;
                flex-shrink: 0;
                overflow: auto;
            }

            .panel-header {
                padding: 8px 16px;
                background-color: #3a3a3a;
                font-weight: 500;
                border-bottom: 1px solid #444;
                flex-shrink: 0;
            }

            .panel-content {
                flex: 1;
                padding: 16px;
                overflow-y: auto;
                position: relative;
            }

            /* 속성 패널 내용: 입력란들을 감싸는 영역 */
            #propertiesFields {
                display: block;
            }

            /* 선택된 클립이 없을 때 보여줄 메시지 */
            #noSelectionMessage {
                text-align: center;
                color: #aaa;
                padding: 20px;
                display: none;
            }

            /* 텍스트 전용 속성은 별도 컨테이너에 담음 */
            .text-properties {
                margin-bottom: 16px;
            }

            /* 동그라미/사각형 전용 속성 (색상 선택) */
            .shape-properties {
                margin-bottom: 16px;
            }

            /* 채우기 전용 속성 (색상 선택) */
            .fill-properties {
                margin-bottom: 16px;
            }

            .setting-group {
                margin-bottom: 16px;
            }

            .setting-label {
                margin-bottom: 4px;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            input[type="text"],
            input[type="number"],
            select {
                width: 100%;
                padding: 4px;
                margin-bottom: 8px;
                background-color: #444;
                border: 1px solid #555;
                color: #fff;
                font-size: 0.9rem;
                border-radius: 4px;
            }

            .style-buttons {
                display: flex;
                gap: 8px;
            }

            .style-toggle {
                background: #444;
                border: none;
                color: #fff;
                padding: 6px 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 1rem;
                transition: background 0.2s;
            }

            .style-toggle:hover {
                background: #666;
            }

            .style-toggle.active {
                background: #55aaff;
            }

            .graph-container {
                border: 1px solid #555;
                background-color: #111;
                height: 150px;
                position: relative;
                margin-bottom: 16px;
                overflow: hidden;
            }

            .graph-line {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }

            /* 그래프 꼭지점: 기본 크기는 그대로 두되, 가상요소로 넓은 히트영역 제공 */
            .graph-point {
                position: absolute;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                background-color: #f0ad4e;
                cursor: pointer;
                transform: translate(-50%, -50%);
            }

            .graph-point::before {
                content: "";
                position: absolute;
                top: -5px;
                left: -5px;
                width: 20px;
                height: 20px;
            }

            .graph-label {
                position: absolute;
                font-size: 10px;
                color: #fff;
                background-color: rgba(0, 0, 0, 0.5);
                padding: 2px 4px;
                border-radius: 2px;
                white-space: nowrap;
                cursor: pointer;
            }

            .graph-context-menu {
                position: absolute;
                background-color: #444;
                border: 1px solid #666;
                display: none;
                z-index: 9999;
                padding: 4px;
            }

            .graph-context-menu div {
                padding: 4px 12px;
                cursor: pointer;
            }

            .graph-context-menu div:hover {
                background-color: #555;
            }

            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }

            ::-webkit-scrollbar-track {
                background: #2c2c2c;
            }

            ::-webkit-scrollbar-thumb {
                background: #555;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #666;
            }

            .timeline-body {
                flex: 1;
                overflow: auto;
                padding: 8px;
                position: relative;
            }

            /* 모달 창 (엔트리 내보내기 및 불러오기) 스타일 */
            #exportModal,
            #importModal {
                display: none;
                position: fixed;
                z-index: 2000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.5);
            }

            .export-modal-content {
                background-color: #333;
                margin: 10% auto;
                padding: 20px;
                border: 1px solid #444;
                width: 80%;
                max-width: 600px;
                color: #fff;
                border-radius: 8px;
                position: relative;
            }

            .close-modal {
                color: #aaa;
                float: right;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
            }

            .close-modal:hover {
                color: #fff;
            }

            /* export pre 스타일: 자동 줄바꿈, 스크롤 등 */
            #exportCode {
                white-space: pre-wrap;
                word-wrap: break-word;
                max-height: 300px;
                overflow: auto;
                background-color: #222;
                padding: 10px;
                border-radius: 4px;
                margin-top: 10px;
            }

            .rotation-handle {
                /* (이미 인라인으로 지정했으므로 선택 사항입니다.) */
                width: 12px;
                height: 12px;
                background-color: red;
                border-radius: 50%;
                position: absolute;
                top: -20px;
                left: 50%;
                transform: translateX(-50%);
                cursor: grab;
            }

            .scale-handle {
                width: 12px;
                height: 12px;
                background-color: blue;
                position: absolute;
                bottom: -10px;
                right: -10px;
                cursor: nwse-resize;
            }
        </style>
    </head>

    <body>
        <!-- 상단 메뉴 -->
        <div class="top-menu">
            <div class="logo">타이포 메이커</div>
            <!-- 배경음악 추가 버튼 (엔트리 내보내기 왼쪽) -->
            <div id="bgMusicAdd" class="menu-item">
                <i class="fa-solid fa-music"></i> 배경음악 추가
            </div>
            <span id="bgMusicFileName">음원 없음</span>

            <!-- 볼륨 조절 슬라이더 (재생 버튼 오른쪽) -->
            <input
                type="range"
                id="bgVolumeControl"
                min="0"
                max="1"
                step="0.01"
                value="1"
                title="Volume Control"
            />
            <!-- 엔트리 내보내기 버튼 -->
            <div id="exportEntry" class="menu-item">
                <i class="fa-solid fa-file-export"></i> 엔트리 내보내기
            </div>
            <!-- 엔트리 불러오기 버튼 -->
            <div id="importEntry" class="menu-item">
                <i class="fa-solid fa-file-import"></i> 엔트리 불러오기
            </div>
            <!-- 헤더: 프리뷰 16:9 영역 배경색 선택 -->
            <div class="menu-item preview-bg-item" style="margin-left: auto">
                <label for="previewBgColor" style="cursor: pointer"
                    ><i class="fa-solid fa-fill-drip"></i> 미리보기
                    배경색</label
                >
                <input
                    type="color"
                    id="previewBgColor"
                    value="#000000"
                    style="margin-left: 4px; border: none; background: none"
                />
            </div>
        </div>
        <!-- 배경음악 파일 선택 input (화면에 보이지 않음) -->
        <input
            type="file"
            id="bgMusicInput"
            accept="audio/*"
            style="display: none"
        />

        <!-- 메인 컨테이너 -->
        <div class="main-container">
            <!-- 중앙 영역 (프리뷰 + 타임라인) -->
            <div class="center-area">
                <!-- 프리뷰 영역 -->
                <div class="preview-container">
                    <div class="preview" id="preview">
                        <!-- 16:9 영역에 배경색이 적용됩니다 -->
                        <div class="preview-content"></div>
                    </div>
                    <div class="player-controls">
                        <button id="rewindBtn" title="처음으로 이동">
                            <svg
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                            >
                                <path
                                    d="M11 19L2 12l9-7v14zM22 19l-9-7 9-7v14z"
                                ></path>
                            </svg>
                        </button>
                        <button id="togglePlayBtn" title="재생">
                            <svg
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                            >
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                        </button>
                        <span id="currentTimeLabel">0.00</span>
                    </div>
                </div>
                <!-- 타임라인 영역 -->
                <div class="timeline-area">
                    <div class="timeline-header">
                        <!-- 네 종류의 클립 추가 버튼 (텍스트, 사각형, 원, 채우기) -->
                        <button id="addTextBtn">
                            <i class="fa-solid fa-font"></i> 텍스트 추가
                        </button>
                        <button id="addRectBtn">
                            <i class="fa-solid fa-square"></i> 사각형 추가
                        </button>
                        <button id="addCircleBtn">
                            <i class="fa-solid fa-circle"></i> 원 추가
                        </button>
                        <button id="addFillBtn">
                            <i class="fa-solid fa-square-full"></i> 채우기 추가
                        </button>
                        <button id="addTrackBtn">
                            <i class="fa-solid fa-layer-group"></i> 트랙 추가
                        </button>
                        <button id="deleteTrackBtn">
                            <i class="fa-solid fa-trash"></i> 트랙 삭제
                        </button>
                        <span class="track-label"
                            ><i class="fa-solid fa-bars"></i> 트랙</span
                        >
                        <label for="maxDuration"
                            ><i class="fa-solid fa-hourglass"></i> 최대
                            시간(초):</label
                        >
                        <input
                            type="number"
                            id="maxDuration"
                            value="300"
                            style="width: 60px; margin-left: 4px"
                        />
                    </div>
                    <div class="timeline-body" id="timelineBody">
                        <div id="timeIndicator"></div>
                        <div id="trackContextMenu" class="track-context-menu">
                            <div id="trackDelete">트랙 삭제</div>
                            <div id="trackCopy">트랙 복사</div>
                            <div id="trackPaste">트랙 붙여넣기</div>
                        </div>
                        <!-- 예시 트랙 -->
                        <div class="track"></div>
                        <div class="track"></div>
                        <div class="track"></div>
                        <div class="track"></div>
                    </div>
                </div>
            </div>
            <!-- Resizer -->
            <div id="resizer"></div>
            <!-- 우측 패널 (Properties) -->
            <div class="right-panel">
                <div class="panel-header">속성</div>
                <div class="panel-content">
                    <!-- 선택된 클립이 없을 때 표시할 메시지 -->
                    <div id="noSelectionMessage">선택된 클립이 없습니다.</div>
                    <!-- 속성 입력란들을 감싼 영역 -->
                    <div id="propertiesFields">
                        <!-- 텍스트 전용 속성 (클립이 텍스트일 때만 보임) -->
                        <div class="text-properties">
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-pen"></i> 텍스트 내용
                                </div>
                                <input type="text" id="textContent" />
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-font"></i> 글꼴
                                </div>
                                <select id="fontFamily">
                                    <option value="나눔고딕">나눔고딕</option>
                                    <option value="나눔명조">나눔명조</option>
                                    <option value="나눔바른펜">
                                        나눔바른펜
                                    </option>
                                    <option value="나눔손글씨">
                                        나눔손글씨
                                    </option>
                                    <option value="나눔스퀘어라운드">
                                        나눔스퀘어라운드
                                    </option>
                                    <option value="마루 부리">마루 부리</option>
                                    <option value="본고딕">본고딕</option>
                                    <option value="D2 Coding">D2 Coding</option>
                                    <option value="잘난체">잘난체</option>
                                    <option value="디자인하우스체">
                                        디자인하우스체
                                    </option>
                                    <option value="둥근모꼴체">
                                        둥근모꼴체
                                    </option>
                                    <option value="어비마이센체">
                                        어비마이센체
                                    </option>
                                </select>
                            </div>
                            <!-- 텍스트 스타일 버튼 -->
                            <div class="setting-group text-style-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-pencil"></i> 텍스트
                                    스타일
                                </div>
                                <div class="style-buttons">
                                    <button
                                        type="button"
                                        id="boldBtn"
                                        class="style-toggle"
                                        title="굵게"
                                    >
                                        <i class="fa-solid fa-bold"></i>
                                    </button>
                                    <button
                                        type="button"
                                        id="italicBtn"
                                        class="style-toggle"
                                        title="기울임"
                                    >
                                        <i class="fa-solid fa-italic"></i>
                                    </button>
                                    <button
                                        type="button"
                                        id="underlineBtn"
                                        class="style-toggle"
                                        title="밑줄"
                                    >
                                        <i class="fa-solid fa-underline"></i>
                                    </button>
                                    <button
                                        type="button"
                                        id="strikethroughBtn"
                                        class="style-toggle"
                                        title="취소선"
                                    >
                                        <i
                                            class="fa-solid fa-strikethrough"
                                        ></i>
                                    </button>
                                </div>
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-font"></i> 글자 색상
                                </div>
                                <input
                                    type="color"
                                    id="textColor"
                                    value="#ffffff"
                                />
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-fill-drip"></i> 배경색
                                </div>
                                <input
                                    type="color"
                                    id="bgColor"
                                    value="#000000"
                                />
                            </div>
                            <!-- 배경 투명 체크박스 추가 -->
                            <div class="setting-group">
                                <input type="checkbox" id="bgTransparent" />
                                <label for="bgTransparent">배경 투명</label>
                            </div>
                        </div>
                        <!-- 동그라미/사각형 전용 속성 -->
                        <div class="shape-properties" style="display: none">
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-palette"></i> 도형
                                    색상
                                </div>
                                <select id="shapeColor">
                                    <option value="#FF0000">빨강</option>
                                    <option value="#FFA500">주황</option>
                                    <option value="#FFFF00">노랑</option>
                                    <option value="#008000">초록</option>
                                    <option value="#0000FF">파랑</option>
                                    <option value="#800080">보라</option>
                                </select>
                            </div>
                        </div>
                        <div class="fill-properties" style="display: none">
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-fill-drip"></i> 채우기
                                    색상
                                </div>
                                <input
                                    type="color"
                                    id="fillColor"
                                    value="#ffffff"
                                />
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-clock"></i> 시작 시간
                                </div>
                                <input
                                    type="number"
                                    id="fillStartTime"
                                    value="0"
                                    step="0.01"
                                />
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-stopwatch"></i> 종료
                                    시간
                                </div>
                                <input
                                    type="number"
                                    id="fillEndTime"
                                    value="5"
                                    step="0.01"
                                />
                            </div>
                        </div>
                        <!-- 공통 속성 (텍스트, 도형 클립에 적용 – 채우기는 숨김) -->
                        <div id="commonProperties">
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-clock"></i> 시작 시간
                                </div>
                                <input type="number" id="startTime" />
                            </div>
                            <div class="setting-group">
                                <div class="setting-label">
                                    <i class="fa-solid fa-stopwatch"></i> 종료
                                    시간
                                </div>
                                <input type="number" id="endTime" />
                            </div>
                            <div class="setting-group ease-select">
                                <div class="setting-label">
                                    <i class="fa-solid fa-arrows-alt-h"></i>
                                    포지션 X 보간
                                </div>
                                <select id="easePosX">
                                    <option value="linear">Linear</option>
                                    <option value="easeIn">EaseIn</option>
                                    <option value="easeOut">EaseOut</option>
                                    <option value="easeInOut">EaseInOut</option>
                                </select>
                            </div>
                            <div class="setting-label">포지션 X 그래프</div>
                            <div class="graph-container" id="graphX">
                                <svg class="graph-line"></svg>
                                <div class="graph-context-menu" id="graphXMenu">
                                    <div data-action="add">키프레임 추가</div>
                                </div>
                            </div>
                            <div class="setting-group ease-select">
                                <div class="setting-label">
                                    <i class="fa-solid fa-arrows-alt-v"></i>
                                    포지션 Y 보간
                                </div>
                                <select id="easePosY">
                                    <option value="linear">Linear</option>
                                    <option value="easeIn">EaseIn</option>
                                    <option value="easeOut">EaseOut</option>
                                    <option value="easeInOut">EaseInOut</option>
                                </select>
                            </div>
                            <div class="setting-label">포지션 Y 그래프</div>
                            <div class="graph-container" id="graphY">
                                <svg class="graph-line"></svg>
                                <div class="graph-context-menu" id="graphYMenu">
                                    <div data-action="add">키프레임 추가</div>
                                </div>
                            </div>
                            <div class="setting-group ease-select">
                                <div class="setting-label">
                                    <i class="fa-solid fa-expand"></i> 크기 보간
                                </div>
                                <select id="easeScale">
                                    <option value="linear">Linear</option>
                                    <option value="easeIn">EaseIn</option>
                                    <option value="easeOut">EaseOut</option>
                                    <option value="easeInOut">EaseInOut</option>
                                </select>
                            </div>
                            <div class="setting-label">크기 그래프</div>
                            <div class="graph-container" id="graphScale">
                                <svg class="graph-line"></svg>
                                <div
                                    class="graph-context-menu"
                                    id="graphScaleMenu"
                                >
                                    <div data-action="add">키프레임 추가</div>
                                </div>
                            </div>
                            <div class="setting-group ease-select">
                                <div class="setting-label">
                                    <i class="fa-solid fa-rotate-right"></i>
                                    회전 보간
                                </div>
                                <select id="easeRotation">
                                    <option value="linear">Linear</option>
                                    <option value="easeIn">EaseIn</option>
                                    <option value="easeOut">EaseOut</option>
                                    <option value="easeInOut">EaseInOut</option>
                                </select>
                            </div>
                            <div class="setting-label">회전 그래프</div>
                            <div class="graph-container" id="graphRotation">
                                <svg class="graph-line"></svg>
                                <div
                                    class="graph-context-menu"
                                    id="graphRotationMenu"
                                >
                                    <div data-action="add">키프레임 추가</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 엔트리 내보내기 모달 (내보내기 데이터가 표시됨) -->
        <div id="exportModal">
            <div class="export-modal-content">
                <span class="close-modal">&times;</span>
                <!-- 복사 버튼 추가 -->
                <button id="copyExportCode" style="margin-bottom: 10px">
                    복사하기
                </button>
                <button id="exportFile" style="margin-bottom: 10px">
                    파일로 내보내기
                </button>
                <span
                    >mp3 외의 포멧은 오프라인 엔트리에서만 재생할 수
                    있습니다</span
                >
                <pre id="exportCode"></pre>
            </div>
        </div>

        <!-- 엔트리 불러오기 모달 -->
        <div id="importModal">
            <div class="export-modal-content">
                <span class="close-modal import-close-modal">&times;</span>
                <textarea
                    id="importCode"
                    placeholder="엔트리 프로젝트 코드를 붙여넣으세요"
                    style="
                        width: 100%;
                        height: 200px;
                        background-color: #222;
                        padding: 10px;
                        border-radius: 4px;
                        margin-top: 10px;
                        color: #fff;
                        border: none;
                    "
                ></textarea>
                <button id="importEntryBtn" style="margin-top: 10px">
                    불러오기
                </button>
            </div>
        </div>
        <script src="https://rawcdn.githack.com/ankitrohatgi/tarballjs/refs/heads/master/tarball.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <!-- 스크립트 -->
        <script>
            (function () {
                let isPlaying = false;
                let currentTime = 0;
                let lastTimestamp = 0;
                let copiedClipData = null;
                let undoStack = [];
                let redoStack = [];
                let totalDuration = 300; // 최대 시간(초)
                const PIXELS_PER_SECOND = 50;
                let trackList = Array.from(
                    document.querySelectorAll(".timeline-body .track")
                );
                let clipsData = {}; // 클립별 데이터 저장
                let selectedClip = null;
                let copiedTrackData = null;
                let draggingTimeIndicator = false;
                let timeIndicatorOffsetX = 0;
                let dragClip = null;
                let dragOffsetX = 0;
                let resizeClipElem = null;
                let resizeClipOrigWidth = 0;
                let resizeClipStartX = 0;
                let clipResizeLeftElem = null;
                let clipResizeLeftOrigLeft = 0;
                let clipResizeLeftOrigWidth = 0;
                let clipResizeLeftStartX = 0;
                let _graphDragInfo = null;
                let bgAudio = null;
                let bgAudioBlob = null;
                deselectClip();

                // 전역 변수로 회전 드래그 관련 데이터를 저장
                let previewRotationData = null;

                function onPreviewRotationMouseDown(e) {
                    e.stopPropagation();
                    // 부모 요소(클립 요소)에서 클립 ID 읽기
                    const clipId =
                        e.currentTarget.parentNode.getAttribute("data-clip-id");
                    if (!clipId) return;
                    // 타임라인의 해당 클립도 선택 (선택 시 속성 패널 갱신)
                    const timelineClip = document.getElementById(clipId);
                    if (timelineClip) {
                        selectClip(timelineClip);
                    }
                    // 요소의 중앙 좌표 계산
                    const rect =
                        e.currentTarget.parentNode.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    // 마우스 시작 각도 계산 (라디안)
                    const startAngle = Math.atan2(
                        e.clientY - centerY,
                        e.clientX - centerX
                    );
                    previewRotationData = {
                        clipId: clipId,
                        centerX: centerX,
                        centerY: centerY,
                        startAngle: startAngle,
                        originalRotation: clipsData[clipId].rotation[0].value, // 첫번째 키프레임 기준
                    };
                    document.addEventListener(
                        "mousemove",
                        onPreviewRotationMouseMove
                    );
                    document.addEventListener(
                        "mouseup",
                        onPreviewRotationMouseUp
                    );
                }

                function onPreviewRotationMouseMove(e) {
                    if (!previewRotationData) return;
                    // 현재 각도 계산
                    const angle = Math.atan2(
                        e.clientY - previewRotationData.centerY,
                        e.clientX - previewRotationData.centerX
                    );
                    // 시작 각도와의 차이를 구한 후, 도(degree) 단위로 변환
                    const deltaAngle =
                        (angle - previewRotationData.startAngle) *
                        (180 / Math.PI);
                    const newRotation =
                        previewRotationData.originalRotation + deltaAngle;
                    const clip = clipsData[previewRotationData.clipId];
                    // 첫번째와 마지막 키프레임 값을 업데이트 (필요 시 보간 로직 수정 가능)
                    clip.rotation[0].value = newRotation;
                    clip.rotation[clip.rotation.length - 1].value = newRotation;
                    updatePreview(currentTime);
                }

                function onPreviewRotationMouseUp(e) {
                    previewRotationData = null;
                    document.removeEventListener(
                        "mousemove",
                        onPreviewRotationMouseMove
                    );
                    document.removeEventListener(
                        "mouseup",
                        onPreviewRotationMouseUp
                    );
                }

                // 전역 변수로 스케일 드래그 관련 데이터를 저장
                let previewScaleData = null;

                function onPreviewScaleMouseDown(e) {
                    e.stopPropagation();
                    const clipId =
                        e.currentTarget.parentNode.getAttribute("data-clip-id");
                    if (!clipId) return;
                    const timelineClip = document.getElementById(clipId);
                    if (timelineClip) {
                        selectClip(timelineClip);
                    }
                    const rect =
                        e.currentTarget.parentNode.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    // 마우스 시작 시 중심과의 거리 계산
                    const startDistance = Math.hypot(
                        e.clientX - centerX,
                        e.clientY - centerY
                    );
                    previewScaleData = {
                        clipId: clipId,
                        centerX: centerX,
                        centerY: centerY,
                        startDistance: startDistance,
                        originalScale: clipsData[clipId].scale[0].value, // 첫번째 키프레임 기준 (예: 기본값 100)
                    };
                    document.addEventListener(
                        "mousemove",
                        onPreviewScaleMouseMove
                    );
                    document.addEventListener("mouseup", onPreviewScaleMouseUp);
                }

                function onPreviewScaleMouseMove(e) {
                    if (!previewScaleData) return;
                    const newDistance = Math.hypot(
                        e.clientX - previewScaleData.centerX,
                        e.clientY - previewScaleData.centerY
                    );
                    const ratio = newDistance / previewScaleData.startDistance;
                    let newScale = previewScaleData.originalScale * ratio;
                    // 기존에 사용한 clamp 함수를 이용하여 크기를 제한 (예: 20 ~ 500)
                    newScale = clamp(newScale, 20, 500);
                    const clip = clipsData[previewScaleData.clipId];
                    clip.scale[0].value = newScale;
                    clip.scale[clip.scale.length - 1].value = newScale;
                    updatePreview(currentTime);
                }

                function onPreviewScaleMouseUp(e) {
                    previewScaleData = null;
                    document.removeEventListener(
                        "mousemove",
                        onPreviewScaleMouseMove
                    );
                    document.removeEventListener(
                        "mouseup",
                        onPreviewScaleMouseUp
                    );
                }

                // 전역 변수 (프리뷰 드래그 관련)
                let previewDragData = null;

                function onPreviewMouseDown(e) {
                    e.stopPropagation();
                    // 클릭한 프리뷰 요소에서 클립 ID 읽기
                    const clipId = e.currentTarget.getAttribute("data-clip-id");
                    if (!clipId) return;

                    // 프리뷰에서 드래그 시작 시 타임라인의 해당 클립도 선택합니다.
                    const timelineClip = document.getElementById(clipId);
                    if (timelineClip) {
                        selectClip(timelineClip);
                    }

                    previewDragData = {
                        clipId: clipId,
                        startX: e.clientX,
                        startY: e.clientY,
                        // 현재 클립의 posX, posY의 첫번째(및 마지막) 값을 저장합니다.
                        originalPosX: clipsData[clipId].posX[0].value,
                        originalPosY: clipsData[clipId].posY[0].value,
                    };
                    // 드래그 이동/종료 이벤트를 document에 등록합니다.
                    document.addEventListener("mousemove", onPreviewMouseMove);
                    document.addEventListener("mouseup", onPreviewMouseUp);
                }

                function onPreviewMouseMove(e) {
                    if (!previewDragData) return;
                    const deltaX = e.clientX - previewDragData.startX;
                    const deltaY = e.clientY - previewDragData.startY;

                    // 프리뷰에서 transform에 적용했던 계산식을 참고합니다.
                    // 예를 들어, updatePreview에서는 다음과 같이 계산했다고 가정합니다:
                    // xVal = clamp(posX, -240, 240) * 1.6, yVal = -clamp(posY, -135, 135) * 1.6
                    // 따라서 역으로 delta값을 keyframe 값의 변화로 환산합니다.
                    const deltaValueX = deltaX / 1.6;
                    const deltaValueY = -deltaY / 1.6; // Y는 부호 반전

                    const clip = clipsData[previewDragData.clipId];
                    // 첫번째와 마지막 키프레임의 값을 업데이트 (원하는 방식에 따라 수정 가능)
                    clip.posX[0].value =
                        previewDragData.originalPosX + deltaValueX;
                    clip.posX[clip.posX.length - 1].value =
                        previewDragData.originalPosX + deltaValueX;
                    clip.posY[0].value =
                        previewDragData.originalPosY + deltaValueY;
                    clip.posY[clip.posY.length - 1].value =
                        previewDragData.originalPosY + deltaValueY;

                    // 프리뷰를 갱신하여 즉각 반영합니다.
                    updatePreview(currentTime);
                }

                function onPreviewMouseUp(e) {
                    previewDragData = null;
                    document.removeEventListener(
                        "mousemove",
                        onPreviewMouseMove
                    );
                    document.removeEventListener("mouseup", onPreviewMouseUp);
                }

                // ── 유틸리티 함수 ──
                function clamp(val, min, max) {
                    return Math.min(Math.max(val, min), max);
                }

                function getSafeXInTrack(
                    track,
                    clipWidth,
                    candidateX,
                    ignoreClip
                ) {
                    let siblings = Array.from(
                        track.querySelectorAll(".clip")
                    ).filter((c) => c !== ignoreClip);
                    if (siblings.length === 0) {
                        return clamp(
                            candidateX,
                            0,
                            track.clientWidth - clipWidth
                        );
                    }
                    siblings.sort(
                        (a, b) =>
                            parseFloat(a.style.left) - parseFloat(b.style.left)
                    );
                    let safeZones = [];
                    let firstLeft = parseFloat(siblings[0].style.left) || 0;
                    if (firstLeft >= clipWidth) {
                        safeZones.push({
                            start: 0,
                            end: firstLeft - clipWidth,
                        });
                    }
                    for (let i = 0; i < siblings.length - 1; i++) {
                        let currentRight =
                            (parseFloat(siblings[i].style.left) || 0) +
                            siblings[i].offsetWidth;
                        let nextLeft =
                            parseFloat(siblings[i + 1].style.left) || 0;
                        if (nextLeft - currentRight >= clipWidth) {
                            safeZones.push({
                                start: currentRight,
                                end: nextLeft - clipWidth,
                            });
                        }
                    }
                    let lastRight =
                        (parseFloat(siblings[siblings.length - 1].style.left) ||
                            0) + siblings[siblings.length - 1].offsetWidth;
                    let trackWidth = track.clientWidth;
                    if (trackWidth - lastRight >= clipWidth) {
                        safeZones.push({
                            start: lastRight,
                            end: trackWidth - clipWidth,
                        });
                    }
                    if (safeZones.length === 0) {
                        return clamp(candidateX, 0, trackWidth - clipWidth);
                    }
                    for (let zone of safeZones) {
                        if (
                            candidateX >= zone.start &&
                            candidateX <= zone.end
                        ) {
                            return candidateX;
                        }
                    }
                    let closest = safeZones[0].start;
                    let minDist = Math.abs(candidateX - safeZones[0].start);
                    for (let zone of safeZones) {
                        let d1 = Math.abs(candidateX - zone.start);
                        if (d1 < minDist) {
                            minDist = d1;
                            closest = zone.start;
                        }
                        let d2 = Math.abs(candidateX - zone.end);
                        if (d2 < minDist) {
                            minDist = d2;
                            closest = zone.end;
                        }
                    }
                    return closest;
                }

                function updateTimeIndicator() {
                    const indicator = document.getElementById("timeIndicator");
                    if (indicator) {
                        indicator.style.left =
                            currentTime * PIXELS_PER_SECOND + "px";
                    }
                }

                function getTrackForY(clientY) {
                    const tracks = document.querySelectorAll(
                        ".timeline-body .track"
                    );
                    for (let track of tracks) {
                        const rect = track.getBoundingClientRect();
                        if (clientY >= rect.top && clientY <= rect.bottom) {
                            return track;
                        }
                    }
                    return tracks[tracks.length - 1];
                }

                function createTrack() {
                    const body = document.getElementById("timelineBody");
                    const trackDom = document.createElement("div");
                    trackDom.className = "track";
                    trackDom.style.height = "60px";
                    trackDom.style.width =
                        totalDuration * PIXELS_PER_SECOND + "px";
                    trackDom.addEventListener(
                        "contextmenu",
                        onTrackContextMenu
                    );
                    body.appendChild(trackDom);
                    trackList.push(trackDom);
                }

                let trackContextTarget = null;
                function onTrackContextMenu(e) {
                    e.preventDefault();
                    trackContextTarget = e.currentTarget;
                    const menu = document.getElementById("trackContextMenu");
                    menu.style.display = "block";
                    menu.style.left = e.pageX + "px";
                    menu.style.top = e.pageY + "px";
                    document.addEventListener("click", hideTrackMenu, {
                        once: true,
                    });
                }
                function hideTrackMenu() {
                    const menu = document.getElementById("trackContextMenu");
                    if (menu) menu.style.display = "none";
                    trackContextTarget = null;
                }
                function onTrackDelete() {
                    if (!trackContextTarget) return;
                    const clipsInTrack =
                        trackContextTarget.querySelectorAll(".clip");
                    clipsInTrack.forEach((clip) => {
                        delete clipsData[clip.id];
                    });
                    trackContextTarget.remove();
                    const idx = trackList.indexOf(trackContextTarget);
                    if (idx >= 0) {
                        trackList.splice(idx, 1);
                    }
                    hideTrackMenu();
                }
                function onTrackCopy() {
                    if (!trackContextTarget) return;
                    const idx = trackList.indexOf(trackContextTarget);
                    if (idx < 0) return;
                    const trackIndex = idx + 1;
                    const trackClips = [];
                    for (let cid in clipsData) {
                        if (clipsData[cid].trackIndex === trackIndex) {
                            trackClips.push({ ...clipsData[cid] });
                        }
                    }
                    copiedTrackData = { clips: trackClips };
                    hideTrackMenu();
                }
                function onTrackPaste() {
                    if (!trackContextTarget || !copiedTrackData) return;
                    const idx = trackList.indexOf(trackContextTarget);
                    if (idx < 0) return;
                    const newTrackIndex = idx + 1;
                    copiedTrackData.clips.forEach((c) => {
                        const newId =
                            "clip-" + Math.random().toString(36).substr(2, 9);
                        const st = c.startTime;
                        const ed = c.endTime;
                        const clipDom = createClipDom(newId, st, ed, c.type);
                        if (trackList[newTrackIndex - 1]) {
                            trackList[newTrackIndex - 1].appendChild(clipDom);
                            clipsData[newId] = {
                                ...c,
                                id: newId,
                                trackIndex: newTrackIndex,
                            };
                        }
                    });
                    hideTrackMenu();
                }
                function findAvailableTrack(st, ed) {
                    for (let i = 0; i < trackList.length; i++) {
                        if (isTrackEmptyFor(i + 1, st, ed)) {
                            return i + 1;
                        }
                    }
                    return null;
                }
                function isTrackEmptyFor(
                    trackIndex,
                    st,
                    ed,
                    ignoreClipId = null
                ) {
                    for (let cid in clipsData) {
                        if (ignoreClipId && cid === ignoreClipId) continue;
                        const c = clipsData[cid];
                        if (c.trackIndex === trackIndex) {
                            if (!(ed <= c.startTime || st >= c.endTime)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                function saveState() {
                    const state = {
                        clipsData: JSON.parse(JSON.stringify(clipsData)),
                        currentTime: currentTime,
                        totalDuration: totalDuration,
                    };
                    undoStack.push(state);
                    // 새로운 작업이 발생하면 redoStack은 비워둡니다.
                    redoStack = [];
                }

                /**
                 * 저장된 상태(state)를 복원합니다.
                 * (타임라인의 모든 트랙과 클립 DOM을 제거한 후 state.clipsData를 기준으로 다시 생성)
                 */
                function restoreState(state) {
                    const timelineBody =
                        document.getElementById("timelineBody");
                    // 기존 트랙 DOM 제거
                    timelineBody
                        .querySelectorAll(".track")
                        .forEach((track) => track.remove());
                    trackList = [];
                    // 기존 클립 데이터 초기화
                    clipsData = {};
                    currentTime = state.currentTime;
                    totalDuration = state.totalDuration;

                    // state.clipsData에 저장된 모든 클립을 순회하며 다시 생성
                    for (let cid in state.clipsData) {
                        let clip = state.clipsData[cid];
                        // 해당 클립의 trackIndex에 맞는 트랙이 없으면 생성
                        while (trackList.length < clip.trackIndex) {
                            createTrack();
                        }
                        let newClipDom = createClipDom(
                            cid,
                            clip.startTime,
                            clip.endTime,
                            clip.type
                        );
                        trackList[clip.trackIndex - 1].appendChild(newClipDom);
                        clipsData[cid] = clip;
                    }
                    updatePreview(currentTime);
                    updateTimeIndicator();
                    deselectClip();
                }

                // ── 키보드 단축키 (Ctrl+C, Ctrl+V, Ctrl+Z, Ctrl+Y) ──
                document.addEventListener("keydown", function (e) {
                    // 입력창(Input/Textarea) 안에서는 단축키가 작동하지 않도록 함
                    if (
                        e.target.tagName === "INPUT" ||
                        e.target.tagName === "TEXTAREA"
                    )
                        return;

                    // Ctrl+C : 선택된 클립 복사
                    if (e.ctrlKey && e.key.toLowerCase() === "c") {
                        if (selectedClip) {
                            copiedClipData = JSON.parse(
                                JSON.stringify(clipsData[selectedClip.id])
                            );
                            console.log("클립 복사됨:", copiedClipData);
                            e.preventDefault();
                        }
                    }
                    // Ctrl+V : 복사된 클립 붙여넣기
                    else if (e.ctrlKey && e.key.toLowerCase() === "v") {
                        if (copiedClipData) {
                            // 붙여넣기 전 현재 상태를 저장
                            saveState();
                            let offset = 0.5; // 붙여넣기 시 원본과 겹치지 않도록 약간의 시간 오프셋 (0.5초)
                            let duration =
                                copiedClipData.endTime -
                                copiedClipData.startTime;
                            let newId =
                                "clip-" +
                                Math.random().toString(36).substr(2, 9);
                            let newClipData = JSON.parse(
                                JSON.stringify(copiedClipData)
                            );
                            newClipData.id = newId;
                            if (selectedClip) {
                                // 선택된 클립이 있다면 같은 트랙에 붙여넣기
                                newClipData.trackIndex =
                                    clipsData[selectedClip.id].trackIndex;
                                newClipData.startTime =
                                    copiedClipData.startTime + offset;
                                newClipData.endTime =
                                    newClipData.startTime + duration;
                            } else {
                                // 선택된 클립이 없다면, 첫 번째 트랙(없으면 새로 생성)과 현재 재생시간을 기준으로 붙여넣기
                                if (trackList.length === 0) {
                                    createTrack();
                                }
                                newClipData.trackIndex = 1;
                                newClipData.startTime = currentTime + offset;
                                newClipData.endTime =
                                    newClipData.startTime + duration;
                            }
                            let newClipDom = createClipDom(
                                newId,
                                newClipData.startTime,
                                newClipData.endTime,
                                newClipData.type
                            );
                            if (trackList[newClipData.trackIndex - 1]) {
                                trackList[
                                    newClipData.trackIndex - 1
                                ].appendChild(newClipDom);
                            }
                            clipsData[newId] = newClipData;
                            selectClip(newClipDom);
                            e.preventDefault();
                        }
                    }
                    // Ctrl+Z : Undo (마지막 상태로 복원)
                    else if (e.ctrlKey && e.key.toLowerCase() === "z") {
                        if (undoStack.length > 0) {
                            let lastState = undoStack.pop();
                            // 현재 상태를 redoStack에 저장
                            let currentState = {
                                clipsData: JSON.parse(
                                    JSON.stringify(clipsData)
                                ),
                                currentTime: currentTime,
                                totalDuration: totalDuration,
                            };
                            redoStack.push(currentState);
                            restoreState(lastState);
                            e.preventDefault();
                        }
                    }
                    // Ctrl+Y : Redo (undo한 상태를 다시 복원)
                    else if (e.ctrlKey && e.key.toLowerCase() === "y") {
                        if (redoStack.length > 0) {
                            let nextState = redoStack.pop();
                            let currentState = {
                                clipsData: JSON.parse(
                                    JSON.stringify(clipsData)
                                ),
                                currentTime: currentTime,
                                totalDuration: totalDuration,
                            };
                            undoStack.push(currentState);
                            restoreState(nextState);
                            e.preventDefault();
                        }
                    }
                });
                function onAddClip(type) {
                    const timelineBody =
                        document.getElementById("timelineBody");
                    const st = timelineBody.scrollLeft / PIXELS_PER_SECOND;
                    const ed = st + 5;
                    let tIndex = findAvailableTrack(st, ed);
                    if (!tIndex) {
                        createTrack();
                        tIndex = trackList.length;
                    }
                    addClipToTrack(tIndex, st, ed, type);
                }

                function onAddText() {
                    onAddClip("text");
                }
                function onAddRect() {
                    onAddClip("rectangle");
                }
                function onAddCircle() {
                    onAddClip("circle");
                }
                function onAddFill() {
                    onAddClip("fill");
                }
                function addClipToTrack(trackIndex, st, ed, type) {
                    const clipId =
                        "clip-" + Math.random().toString(36).substr(2, 9);
                    if (!isTrackEmptyFor(trackIndex, st, ed)) return;
                    const clipDom = createClipDom(clipId, st, ed, type);
                    if (trackList[trackIndex - 1]) {
                        trackList[trackIndex - 1].appendChild(clipDom);
                        if (type === "text") {
                            clipsData[clipId] = {
                                id: clipId,
                                type: "text",
                                content: "새 텍스트",
                                startTime: st,
                                endTime: ed,
                                trackIndex: trackIndex,
                                fontFamily: "나눔고딕",
                                bold: false,
                                italic: false,
                                underline: false,
                                strikethrough: false,
                                textColor: "#ffffff",
                                backgroundColor: "transparent",
                                ease: {
                                    posX: "linear",
                                    posY: "linear",
                                    scale: "linear",
                                    rotation: "linear",
                                },
                                posX: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                                posY: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                                scale: [
                                    { time: 0, value: 100, lockTime: true },
                                    {
                                        time: ed - st,
                                        value: 100,
                                        lockTime: true,
                                    },
                                ],
                                rotation: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                            };
                        } else if (type === "rectangle" || type === "circle") {
                            clipsData[clipId] = {
                                id: clipId,
                                type: type,
                                startTime: st,
                                endTime: ed,
                                trackIndex: trackIndex,
                                ease: {
                                    posX: "linear",
                                    posY: "linear",
                                    scale: "linear",
                                    rotation: "linear",
                                },
                                posX: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                                posY: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                                scale: [
                                    { time: 0, value: 100, lockTime: true },
                                    {
                                        time: ed - st,
                                        value: 100,
                                        lockTime: true,
                                    },
                                ],
                                rotation: [
                                    { time: 0, value: 0, lockTime: true },
                                    { time: ed - st, value: 0, lockTime: true },
                                ],
                                shapeColor: "#FF0000",
                            };
                        } else if (type === "fill") {
                            clipsData[clipId] = {
                                id: clipId,
                                type: "fill",
                                startTime: st,
                                endTime: ed,
                                trackIndex: trackIndex,
                                fillColor: "#ffffff",
                            };
                        }
                    }
                }
                function removeExistingClipContextMenus() {
                    const existing =
                        document.querySelectorAll(".clip-context-menu");
                    existing.forEach((menu) => menu.remove());
                }
                function createClipDom(clipId, st, ed, type) {
                    const clipDom = document.createElement("div");
                    clipDom.className = "clip";
                    clipDom.id = clipId;
                    clipDom.style.left = st * PIXELS_PER_SECOND + "px";
                    clipDom.style.width = (ed - st) * PIXELS_PER_SECOND + "px";
                    clipDom.style.top = "10px";
                    let label = "";
                    if (type === "text") {
                        label = "텍스트";
                    } else if (type === "rectangle") {
                        label = "사각형";
                    } else if (type === "circle") {
                        label = "원";
                    } else if (type === "fill") {
                        label = "채우기";
                    }
                    clipDom.innerHTML = `
                          <div class="clip-handle-l"></div>
                          <div class="clip-label">${label}</div>
                          <div class="clip-handle-r"></div>
                        `;
                    clipDom.addEventListener("mousedown", onClipMouseDown);
                    clipDom
                        .querySelector(".clip-handle-r")
                        .addEventListener("mousedown", onClipResizeMouseDown);
                    clipDom
                        .querySelector(".clip-handle-l")
                        .addEventListener(
                            "mousedown",
                            onClipResizeLeftMouseDown
                        );
                    clipDom.addEventListener("click", () => {
                        selectClip(clipDom);
                    });
                    // 우클릭 시 클립 삭제 컨텍스트 메뉴 표시
                    clipDom.addEventListener("contextmenu", function (e) {
                        e.preventDefault();
                        showClipContextMenu(e, clipDom);
                    });
                    return clipDom;
                }
                function updateStyleButtons() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    document
                        .getElementById("boldBtn")
                        .classList.toggle("active", cdata.bold);
                    document
                        .getElementById("italicBtn")
                        .classList.toggle("active", cdata.italic);
                    document
                        .getElementById("underlineBtn")
                        .classList.toggle("active", cdata.underline);
                    document
                        .getElementById("strikethroughBtn")
                        .classList.toggle("active", cdata.strikethrough);
                }
                function selectClip(clipDom) {
                    document
                        .querySelectorAll(".clip")
                        .forEach((c) => c.classList.remove("selected"));
                    clipDom.classList.add("selected");
                    selectedClip = clipDom;
                    updatePropertiesPanel();
                    updateAllGraphs();
                }
                // 선택 해제 함수: 아무것도 선택되지 않은 경우 처리
                function deselectClip() {
                    selectedClip = null;
                    document
                        .querySelectorAll(".clip")
                        .forEach((c) => c.classList.remove("selected"));
                    updatePropertiesPanel();
                }
                // 속성 패널 업데이트: 선택된 클립이 없으면 입력란 영역은 숨기고 메시지를 보임
                function updatePropertiesPanel() {
                    const fields = document.getElementById("propertiesFields");
                    const msg = document.getElementById("noSelectionMessage");
                    if (!selectedClip) {
                        fields.style.display = "none";
                        msg.style.display = "block";
                        // 기존 값들도 초기화
                        document.getElementById("textContent").value = "";
                        document.getElementById("fontFamily").value = "";
                        document.getElementById("textColor").value = "";
                        document.getElementById("bgColor").value = "";
                        document.getElementById("startTime").value = "";
                        document.getElementById("endTime").value = "";
                        document.getElementById("easePosX").value = "";
                        document.getElementById("easePosY").value = "";
                        document.getElementById("easeScale").value = "";
                        document.getElementById("easeRotation").value = "";
                        return;
                    }
                    fields.style.display = "block";
                    msg.style.display = "none";
                    const cdata = clipsData[selectedClip.id];
                    const textProperties =
                        document.querySelector(".text-properties");
                    const shapeProperties =
                        document.querySelector(".shape-properties");
                    const fillProperties =
                        document.querySelector(".fill-properties");
                    if (cdata.type === "text") {
                        textProperties.style.display = "block";
                        shapeProperties.style.display = "none";
                        fillProperties.style.display = "none";
                        document.getElementById("textContent").value =
                            cdata.content;
                        document.getElementById("fontFamily").value =
                            cdata.fontFamily;
                        document.getElementById("textColor").value =
                            cdata.textColor;
                        document.getElementById("bgColor").value =
                            cdata.backgroundColor === "transparent"
                                ? "#000000"
                                : cdata.backgroundColor;
                        const bgTransChk =
                            document.getElementById("bgTransparent");
                        bgTransChk.checked =
                            cdata.backgroundColor === "transparent";
                        document.getElementById("bgColor").disabled =
                            bgTransChk.checked;
                    } else if (
                        cdata.type === "rectangle" ||
                        cdata.type === "circle"
                    ) {
                        textProperties.style.display = "none";
                        shapeProperties.style.display = "block";
                        fillProperties.style.display = "none";
                        document.getElementById("shapeColor").value =
                            cdata.shapeColor;
                    } else if (cdata.type === "fill") {
                        textProperties.style.display = "none";
                        shapeProperties.style.display = "none";
                        fillProperties.style.display = "block";
                        document.getElementById("fillColor").value =
                            cdata.fillColor;
                        // 새로 추가한 채우기 전용 시간 입력란에 값 반영
                        document.getElementById("fillStartTime").value =
                            cdata.startTime;
                        document.getElementById("fillEndTime").value =
                            cdata.endTime;
                        document.getElementById(
                            "commonProperties"
                        ).style.display = "none";
                        return;
                    } else {
                        document.getElementById(
                            "commonProperties"
                        ).style.display = "";
                    }
                    document.getElementById("commonProperties").style.display =
                        "";
                    document.getElementById("startTime").value =
                        cdata.startTime;
                    document.getElementById("endTime").value = cdata.endTime;
                    document.getElementById("easePosX").value = cdata.ease.posX;
                    document.getElementById("easePosY").value = cdata.ease.posY;
                    document.getElementById("easeScale").value =
                        cdata.ease.scale;
                    document.getElementById("easeRotation").value =
                        cdata.ease.rotation;
                    if (cdata.type === "text") {
                        updateStyleButtons();
                    }
                }
                function onPropChange() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    if (cdata.type === "text") {
                        cdata.content =
                            document.getElementById("textContent").value;
                        cdata.textColor =
                            document.getElementById("textColor").value;
                        // 만약 배경 투명 체크박스가 체크되어 있으면
                        if (document.getElementById("bgTransparent").checked) {
                            cdata.backgroundColor = "transparent";
                        } else {
                            cdata.backgroundColor =
                                document.getElementById("bgColor").value;
                        }
                        selectedClip.querySelector(".clip-label").textContent =
                            cdata.content;
                    } else if (cdata.type === "fill") {
                        cdata.fillColor =
                            document.getElementById("fillColor").value;
                    }
                    let st =
                        parseFloat(
                            document.getElementById("startTime").value
                        ) || 0;
                    let ed =
                        parseFloat(document.getElementById("endTime").value) ||
                        st + 1;
                    if (
                        !isTrackEmptyFor(cdata.trackIndex, st, ed, cdata.id) &&
                        ed > st
                    ) {
                        document.getElementById("startTime").value =
                            cdata.startTime;
                        document.getElementById("endTime").value =
                            cdata.endTime;
                        return;
                    }
                    cdata.startTime = st;
                    cdata.endTime = ed;
                    const dur = ed - st;
                    if (cdata.posX) updateLockKeyframeTime(cdata.posX, dur);
                    if (cdata.posY) updateLockKeyframeTime(cdata.posY, dur);
                    if (cdata.scale) updateLockKeyframeTime(cdata.scale, dur);
                    if (cdata.rotation)
                        updateLockKeyframeTime(cdata.rotation, dur);
                    selectedClip.style.left = st * PIXELS_PER_SECOND + "px";
                    selectedClip.style.width =
                        (ed - st) * PIXELS_PER_SECOND + "px";
                    if (cdata.type === "text") {
                        selectedClip.querySelector(".clip-label").textContent =
                            cdata.content;
                    }
                    updateAllGraphs();
                    updatePreview(currentTime);
                }
                function onEaseChange() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    cdata.ease.posX = document.getElementById("easePosX").value;
                    cdata.ease.posY = document.getElementById("easePosY").value;
                    cdata.ease.scale =
                        document.getElementById("easeScale").value;
                    cdata.ease.rotation =
                        document.getElementById("easeRotation").value;
                    updateAllGraphs();
                    updatePreview(currentTime);
                }
                function onFillTimeChange() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    if (cdata.type !== "fill") return;
                    let st =
                        parseFloat(
                            document.getElementById("fillStartTime").value
                        ) || 0;
                    let ed =
                        parseFloat(
                            document.getElementById("fillEndTime").value
                        ) || st + 1;
                    // (원하는 경우 두 값의 유효성 검사를 추가)
                    cdata.startTime = st;
                    cdata.endTime = ed;
                    // 타임라인에서 clip DOM의 left와 width 갱신
                    selectedClip.style.left = st * PIXELS_PER_SECOND + "px";
                    selectedClip.style.width =
                        (ed - st) * PIXELS_PER_SECOND + "px";
                    updatePreview(currentTime);
                }
                function onFontFamilyChange() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    if (cdata.type !== "text") return;
                    cdata.fontFamily =
                        document.getElementById("fontFamily").value;
                    updatePreview(currentTime);
                }
                function onShapeColorChange() {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    if (cdata.type === "rectangle" || cdata.type === "circle") {
                        cdata.shapeColor =
                            document.getElementById("shapeColor").value;
                        updatePreview(currentTime);
                    }
                }
                function updateLockKeyframeTime(karr, dur) {
                    if (karr.length >= 2) {
                        karr[0].time = 0;
                        karr[karr.length - 1].time = dur;
                    }
                }
                function onClipMouseDown(e) {
                    if (e.button !== 0) return;
                    if (
                        e.target.classList.contains("clip-handle-r") ||
                        e.target.classList.contains("clip-handle-l")
                    )
                        return;
                    dragClip = e.currentTarget;
                    selectClip(dragClip);
                    const rect = dragClip.getBoundingClientRect();
                    dragOffsetX = e.clientX - rect.left;
                    // 드래그 시작 시 no-select 클래스 추가
                    document.body.classList.add("no-select");
                    document.addEventListener("mousemove", onClipDrag);
                    document.addEventListener("mouseup", onClipDragEnd);
                }
                function onClipDrag(e) {
                    if (!dragClip) return;
                    let currentParent = dragClip.parentNode;
                    let parentRect = currentParent.getBoundingClientRect();
                    let newLeft = e.clientX - parentRect.left - dragOffsetX;
                    const newTrack = getTrackForY(e.clientY);
                    if (currentParent !== newTrack) {
                        newTrack.appendChild(dragClip);
                        clipsData[dragClip.id].trackIndex =
                            trackList.indexOf(newTrack) + 1;
                        dragClip.style.top = "10px";
                        currentParent = newTrack;
                        parentRect = currentParent.getBoundingClientRect();
                        newLeft = e.clientX - parentRect.left - dragOffsetX;
                    }
                    newLeft = getSafeXInTrack(
                        currentParent,
                        dragClip.offsetWidth,
                        newLeft,
                        dragClip
                    );
                    dragClip.style.left = newLeft + "px";
                }
                function onClipDragEnd(e) {
                    document.body.classList.remove("no-select"); // 드래그 종료 시 no-select 해제
                    document.removeEventListener("mousemove", onClipDrag);
                    document.removeEventListener("mouseup", onClipDragEnd);
                    if (!dragClip) return;
                    const cdata = clipsData[dragClip.id];
                    const leftPx = parseFloat(dragClip.style.left) || 0;
                    const lengthSec = cdata.endTime - cdata.startTime;
                    const st = leftPx / PIXELS_PER_SECOND;
                    const ed = st + lengthSec;
                    cdata.startTime = st;
                    cdata.endTime = ed;
                    if (cdata.posX)
                        updateLockKeyframeTime(cdata.posX, lengthSec);
                    if (cdata.posY)
                        updateLockKeyframeTime(cdata.posY, lengthSec);
                    if (cdata.scale)
                        updateLockKeyframeTime(cdata.scale, lengthSec);
                    if (cdata.rotation)
                        updateLockKeyframeTime(cdata.rotation, lengthSec);
                    if (selectedClip && selectedClip.id === dragClip.id) {
                        document.getElementById("startTime").value = st;
                        document.getElementById("endTime").value = ed;
                    }
                    dragClip = null;
                }
                function onClipResizeMouseDown(e) {
                    e.stopPropagation();
                    resizeClipElem = e.currentTarget.parentNode;
                    selectClip(resizeClipElem);
                    resizeClipOrigWidth = resizeClipElem.offsetWidth;
                    resizeClipStartX = e.clientX;
                    document.body.classList.add("no-select");
                    document.addEventListener("mousemove", onClipResizing);
                    document.addEventListener("mouseup", onClipResizeEnd);
                }
                function onClipResizing(e) {
                    if (!resizeClipElem) return;
                    const delta = e.clientX - resizeClipStartX;
                    let newWidth = resizeClipOrigWidth + delta;
                    const currentLeft =
                        parseFloat(resizeClipElem.style.left) || 0;
                    let maxWidth =
                        getRightResizeBoundary(resizeClipElem) - currentLeft;
                    newWidth = clamp(newWidth, 20, maxWidth);
                    resizeClipElem.style.width = newWidth + "px";
                    const cdata = clipsData[resizeClipElem.id];
                    const st = currentLeft / PIXELS_PER_SECOND;
                    const ed = st + newWidth / PIXELS_PER_SECOND;
                    cdata.startTime = st;
                    cdata.endTime = ed;
                    if (selectedClip && selectedClip.id === resizeClipElem.id) {
                        document.getElementById("startTime").value = st;
                        document.getElementById("endTime").value = ed;
                    }
                }
                function onClipResizeEnd(e) {
                    document.body.classList.remove("no-select");
                    document.removeEventListener("mousemove", onClipResizing);
                    document.removeEventListener("mouseup", onClipResizeEnd);
                    resizeClipElem = null;
                }
                function getRightResizeBoundary(elem) {
                    const parent = elem.parentNode;
                    const siblings = Array.from(
                        parent.querySelectorAll(".clip")
                    ).filter((c) => c !== elem);
                    let rightBound = parent.clientWidth;
                    const currentLeft = parseFloat(elem.style.left) || 0;
                    siblings.forEach((sib) => {
                        const sibLeft = parseFloat(sib.style.left) || 0;
                        if (sibLeft > currentLeft) {
                            rightBound = Math.min(rightBound, sibLeft);
                        }
                    });
                    return rightBound;
                }
                function onClipResizeLeftMouseDown(e) {
                    e.stopPropagation();
                    clipResizeLeftElem = e.currentTarget.parentNode;
                    selectClip(clipResizeLeftElem);
                    clipResizeLeftOrigLeft =
                        parseFloat(clipResizeLeftElem.style.left) || 0;
                    clipResizeLeftOrigWidth = clipResizeLeftElem.offsetWidth;
                    clipResizeLeftStartX = e.clientX;
                    document.body.classList.add("no-select");
                    document.addEventListener("mousemove", onClipResizingLeft);
                    document.addEventListener("mouseup", onClipResizeLeftEnd);
                }
                function onClipResizingLeft(e) {
                    if (!clipResizeLeftElem) return;
                    const container = clipResizeLeftElem.parentNode;
                    const parentRect = container.getBoundingClientRect();
                    let newLeft = e.clientX - parentRect.left;
                    const currentRight =
                        (parseFloat(clipResizeLeftElem.style.left) || 0) +
                        clipResizeLeftElem.offsetWidth;
                    const minLeft = getLeftResizeBoundary(clipResizeLeftElem);
                    newLeft = clamp(newLeft, minLeft, currentRight - 20);
                    clipResizeLeftElem.style.left = newLeft + "px";
                    clipResizeLeftElem.style.width =
                        currentRight - newLeft + "px";
                    const cdata = clipsData[clipResizeLeftElem.id];
                    cdata.startTime = newLeft / PIXELS_PER_SECOND;
                    if (
                        selectedClip &&
                        selectedClip.id === clipResizeLeftElem.id
                    ) {
                        document.getElementById("startTime").value =
                            cdata.startTime;
                    }
                }
                function onClipResizeLeftEnd(e) {
                    document.body.classList.remove("no-select");
                    document.removeEventListener(
                        "mousemove",
                        onClipResizingLeft
                    );
                    document.removeEventListener(
                        "mouseup",
                        onClipResizeLeftEnd
                    );
                    clipResizeLeftElem = null;
                }
                function getLeftResizeBoundary(elem) {
                    const parent = elem.parentNode;
                    const siblings = Array.from(
                        parent.querySelectorAll(".clip")
                    ).filter((c) => c !== elem);
                    let leftBound = 0;
                    siblings.forEach((sib) => {
                        const sibRight =
                            (parseFloat(sib.style.left) || 0) + sib.offsetWidth;
                        const currentLeft = parseFloat(elem.style.left) || 0;
                        if (sibRight <= currentLeft) {
                            leftBound = Math.max(leftBound, sibRight);
                        }
                    });
                    return leftBound;
                }
                function showClipContextMenu(e, clipDom) {
                    e.preventDefault();
                    removeExistingClipContextMenus(); // 기존 메뉴 제거

                    let menu = document.createElement("div");
                    menu.className = "clip-context-menu";
                    menu.style.left = e.pageX + "px";
                    menu.style.top = e.pageY + "px";

                    // [잘라내기] 옵션: 클립을 복사한 후 원본 삭제
                    let cutOption = document.createElement("div");
                    cutOption.innerText = "잘라내기";
                    cutOption.addEventListener("click", function () {
                        // 클립 데이터를 복제하여 복사 변수에 저장
                        copiedClipData = JSON.parse(
                            JSON.stringify(clipsData[clipDom.id])
                        );
                        // 클립 삭제 처리
                        if (clipDom.parentNode) {
                            clipDom.parentNode.removeChild(clipDom);
                        }
                        delete clipsData[clipDom.id];
                        if (selectedClip && selectedClip.id === clipDom.id) {
                            selectedClip = null;
                            updatePropertiesPanel();
                        }
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    });
                    menu.appendChild(cutOption);

                    // [복사] 옵션: 클립 데이터를 복제하여 복사 변수에 저장
                    let copyOption = document.createElement("div");
                    copyOption.innerText = "복사";
                    copyOption.addEventListener("click", function () {
                        copiedClipData = JSON.parse(
                            JSON.stringify(clipsData[clipDom.id])
                        );
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    });
                    menu.appendChild(copyOption);

                    // [붙여넣기] 옵션: 저장된 클립 데이터를 복원하여 붙여넣기
                    let pasteOption = document.createElement("div");
                    pasteOption.innerText = "붙여넣기";
                    pasteOption.addEventListener("click", function () {
                        if (copiedClipData) {
                            // 새 클립 ID 생성
                            let newId =
                                "clip-" +
                                Math.random().toString(36).substr(2, 9);
                            // 복사된 데이터를 deep copy하여 새 클립 데이터로 사용
                            let newClipData = JSON.parse(
                                JSON.stringify(copiedClipData)
                            );
                            newClipData.id = newId;
                            // 원본 클립과 겹치지 않도록 약간의 오프셋(예: 0.5초)을 더함
                            let offset = 0.5;
                            newClipData.startTime += offset;
                            newClipData.endTime += offset;
                            // 새 클립 DOM 생성 (createClipDom 함수 사용)
                            let newClipDom = createClipDom(
                                newId,
                                newClipData.startTime,
                                newClipData.endTime,
                                newClipData.type
                            );
                            // 동일한 트랙에 붙여넣기 (트랙 번호는 newClipData.trackIndex)
                            if (trackList[newClipData.trackIndex - 1]) {
                                trackList[
                                    newClipData.trackIndex - 1
                                ].appendChild(newClipDom);
                            }
                            clipsData[newId] = newClipData;
                        }
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    });
                    menu.appendChild(pasteOption);

                    // [클립 삭제] 옵션 (기존 삭제 기능)
                    let deleteOption = document.createElement("div");
                    deleteOption.innerText = "클립 삭제";
                    deleteOption.addEventListener("click", function () {
                        if (clipDom.parentNode) {
                            clipDom.parentNode.removeChild(clipDom);
                        }
                        delete clipsData[clipDom.id];
                        if (selectedClip && selectedClip.id === clipDom.id) {
                            selectedClip = null;
                            updatePropertiesPanel();
                        }
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    });
                    menu.appendChild(deleteOption);

                    document.body.appendChild(menu);
                    // 메뉴 외부 클릭 시 메뉴를 숨깁니다.
                    document.addEventListener(
                        "click",
                        function handler() {
                            if (document.body.contains(menu)) {
                                document.body.removeChild(menu);
                            }
                        },
                        { once: true }
                    );
                }
                function removeExistingClipContextMenus() {
                    const existing =
                        document.querySelectorAll(".clip-context-menu");
                    existing.forEach((menu) => menu.remove());
                }
                // 미리보기 업데이트 (채우기 클립도 포함하여 트랙 순서대로 정렬)
                function updatePreview(t) {
                    const preview = document.getElementById("preview");
                    const previewContent =
                        preview.querySelector(".preview-content");
                    previewContent.innerHTML = "";

                    // t 시간에 활성화된 클립들을 모음
                    let visibleClips = [];
                    for (let cid in clipsData) {
                        if (!document.getElementById(cid)) continue;
                        const c = clipsData[cid];
                        if (t >= c.startTime && t <= c.endTime) {
                            visibleClips.push(c);
                        }
                    }

                    // 트랙 순서 역순으로 (높은 번호가 먼저 그려지고, 낮은 번호가 아래로 내려감)
                    visibleClips.sort((a, b) => b.trackIndex - a.trackIndex);

                    visibleClips.forEach((c) => {
                        if (c.type === "fill") {
                            const fillEl = document.createElement("div");
                            fillEl.className = "preview-fill";
                            fillEl.style.backgroundColor = c.fillColor;
                            previewContent.appendChild(fillEl);
                        } else {
                            const localT = t - c.startTime;
                            const dur = c.endTime - c.startTime;
                            let xVal = getValueAtTime(
                                c.posX,
                                localT,
                                dur,
                                c.ease.posX
                            );
                            let yVal = getValueAtTime(
                                c.posY,
                                localT,
                                dur,
                                c.ease.posY
                            );
                            xVal = clamp(xVal, -240, 240) * 1.6;
                            yVal = -clamp(yVal, -135, 135) * 1.6;
                            const sc =
                                getValueAtTime(
                                    c.scale,
                                    localT,
                                    dur,
                                    c.ease.scale
                                ) / 50;
                            const rot = getValueAtTime(
                                c.rotation,
                                localT,
                                dur,
                                c.ease.rotation
                            );
                            if (c.type === "text") {
                                const textEl = document.createElement("div");
                                textEl.className = "preview-text";
                                textEl.textContent = c.content;
                                textEl.style.fontFamily = c.fontFamily;
                                textEl.style.fontWeight = c.bold
                                    ? "bold"
                                    : "normal";
                                textEl.style.fontStyle = c.italic
                                    ? "italic"
                                    : "normal";
                                let decorations = [];
                                if (c.underline) decorations.push("underline");
                                if (c.strikethrough)
                                    decorations.push("line-through");
                                textEl.style.textDecoration =
                                    decorations.join(" ") || "none";
                                textEl.style.color = c.textColor;
                                textEl.style.backgroundColor =
                                    c.backgroundColor;
                                textEl.style.transform = `translate(-50%, -50%) translate(${xVal}px, ${yVal}px) rotate(${rot}deg) scale(${sc})`;

                                // 프리뷰와 타임라인 연결: 클립 ID 저장 및 pointer-events 활성화
                                textEl.setAttribute("data-clip-id", c.id);
                                textEl.style.pointerEvents = "auto";
                                textEl.addEventListener(
                                    "mousedown",
                                    onPreviewMouseDown
                                );
                                textEl.style.cursor = "move";

                                // 선택된 클립이면 테두리와 핸들 추가
                                if (selectedClip && selectedClip.id === c.id) {
                                    // 테두리: 1px dashed
                                    textEl.style.outline = "1px dashed #ffcc00";

                                    // 회전 핸들 (상단 중앙; 크기는 8px×8px, 반대 스케일 적용)
                                    const rotationHandle =
                                        document.createElement("div");
                                    rotationHandle.className =
                                        "rotation-handle";
                                    rotationHandle.setAttribute(
                                        "data-handle",
                                        "rotation"
                                    );
                                    rotationHandle.style.position = "absolute";
                                    rotationHandle.style.width = "12px";
                                    rotationHandle.style.height = "12px";
                                    rotationHandle.style.borderRadius = "50%";
                                    rotationHandle.style.backgroundColor =
                                        "red";
                                    rotationHandle.style.top = "-12px";
                                    rotationHandle.style.left = "50%";
                                    // translateX(-50%)로 중앙 정렬 후, 부모 스케일 보정
                                    rotationHandle.style.transform = `translateX(-50%) scale(${
                                        1 / sc
                                    })`;
                                    rotationHandle.style.cursor = "grab";
                                    rotationHandle.addEventListener(
                                        "mousedown",
                                        onPreviewRotationMouseDown
                                    );
                                    textEl.appendChild(rotationHandle);

                                    // 크기 조절 핸들 (네 꼭지점에 6px×6px; 부모 스케일 보정)
                                    const corners = [
                                        {
                                            pos: "top-left",
                                            style: {
                                                top: "-6px",
                                                left: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                        {
                                            pos: "top-right",
                                            style: {
                                                top: "-6px",
                                                right: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-left",
                                            style: {
                                                bottom: "-6px",
                                                left: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-right",
                                            style: {
                                                bottom: "-6px",
                                                right: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                    ];
                                    corners.forEach((corner) => {
                                        const scaleHandle =
                                            document.createElement("div");
                                        scaleHandle.className = "scale-handle";
                                        scaleHandle.setAttribute(
                                            "data-handle",
                                            "scale"
                                        );
                                        scaleHandle.style.position = "absolute";
                                        scaleHandle.style.width = "12px";
                                        scaleHandle.style.height = "12px";
                                        scaleHandle.style.backgroundColor =
                                            "blue";
                                        // 적용할 스타일 속성을 할당
                                        for (const key in corner.style) {
                                            scaleHandle.style[key] =
                                                corner.style[key];
                                        }
                                        // 부모 스케일 보정: 자식 핸들이 항상 고정된 크기로 보임
                                        scaleHandle.style.transform = `scale(${
                                            1 / sc
                                        })`;
                                        scaleHandle.addEventListener(
                                            "mousedown",
                                            onPreviewScaleMouseDown
                                        );
                                        textEl.appendChild(scaleHandle);
                                    });
                                }

                                previewContent.appendChild(textEl);
                            } else if (c.type === "rectangle") {
                                const rectEl = document.createElement("div");
                                rectEl.className = "preview-rect";
                                rectEl.style.width = "80px";
                                rectEl.style.height = "80px";
                                rectEl.style.backgroundColor = c.shapeColor;
                                rectEl.style.transform = `translate(-50%, -50%) translate(${xVal}px, ${yVal}px) rotate(${rot}deg) scale(${sc})`;

                                rectEl.setAttribute("data-clip-id", c.id);
                                rectEl.style.pointerEvents = "auto";
                                rectEl.addEventListener(
                                    "mousedown",
                                    onPreviewMouseDown
                                );
                                rectEl.style.cursor = "move";

                                if (selectedClip && selectedClip.id === c.id) {
                                    rectEl.style.outline = "1px dashed #ffcc00";

                                    // 회전 핸들 (상단 중앙; 8px×8px, 반대 스케일 적용)
                                    const rotationHandle =
                                        document.createElement("div");
                                    rotationHandle.className =
                                        "rotation-handle";
                                    rotationHandle.setAttribute(
                                        "data-handle",
                                        "rotation"
                                    );
                                    rotationHandle.style.position = "absolute";
                                    rotationHandle.style.width = "12px";
                                    rotationHandle.style.height = "12px";
                                    rotationHandle.style.borderRadius = "50%";
                                    rotationHandle.style.backgroundColor =
                                        "red";
                                    rotationHandle.style.top = "-12px";
                                    rotationHandle.style.left = "50%";
                                    rotationHandle.style.transform = `translateX(-50%) scale(${
                                        1 / sc
                                    })`;
                                    rotationHandle.style.cursor = "grab";
                                    rotationHandle.addEventListener(
                                        "mousedown",
                                        onPreviewRotationMouseDown
                                    );
                                    rectEl.appendChild(rotationHandle);

                                    // 네 꼭지점에 크기 조절 핸들 (6px×6px, 반대 스케일 적용)
                                    const corners = [
                                        {
                                            pos: "top-left",
                                            style: {
                                                top: "-6px",
                                                left: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                        {
                                            pos: "top-right",
                                            style: {
                                                top: "-6px",
                                                right: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-left",
                                            style: {
                                                bottom: "-6px",
                                                left: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-right",
                                            style: {
                                                bottom: "-6px",
                                                right: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                    ];
                                    corners.forEach((corner) => {
                                        const scaleHandle =
                                            document.createElement("div");
                                        scaleHandle.className = "scale-handle";
                                        scaleHandle.setAttribute(
                                            "data-handle",
                                            "scale"
                                        );
                                        scaleHandle.style.position = "absolute";
                                        scaleHandle.style.width = "12px";
                                        scaleHandle.style.height = "12px";
                                        scaleHandle.style.backgroundColor =
                                            "blue";
                                        for (const key in corner.style) {
                                            scaleHandle.style[key] =
                                                corner.style[key];
                                        }
                                        scaleHandle.style.transform = `scale(${
                                            1 / sc
                                        })`;
                                        scaleHandle.addEventListener(
                                            "mousedown",
                                            onPreviewScaleMouseDown
                                        );
                                        rectEl.appendChild(scaleHandle);
                                    });
                                }

                                previewContent.appendChild(rectEl);
                            } else if (c.type === "circle") {
                                const circleEl = document.createElement("div");
                                circleEl.className = "preview-circle";
                                circleEl.style.width = "80px";
                                circleEl.style.height = "80px";
                                circleEl.style.backgroundColor = c.shapeColor;
                                circleEl.style.borderRadius = "50%";
                                circleEl.style.transform = `translate(-50%, -50%) translate(${xVal}px, ${yVal}px) rotate(${rot}deg) scale(${sc})`;

                                circleEl.setAttribute("data-clip-id", c.id);
                                circleEl.style.pointerEvents = "auto";
                                circleEl.addEventListener(
                                    "mousedown",
                                    onPreviewMouseDown
                                );
                                circleEl.style.cursor = "move";

                                if (selectedClip && selectedClip.id === c.id) {
                                    circleEl.style.outline =
                                        "1px dashed #ffcc00";

                                    // 회전 핸들 (상단 중앙; 8px×8px, 반대 스케일 적용)
                                    const rotationHandle =
                                        document.createElement("div");
                                    rotationHandle.className =
                                        "rotation-handle";
                                    rotationHandle.setAttribute(
                                        "data-handle",
                                        "rotation"
                                    );
                                    rotationHandle.style.position = "absolute";
                                    rotationHandle.style.width = "12px";
                                    rotationHandle.style.height = "12px";
                                    rotationHandle.style.borderRadius = "50%";
                                    rotationHandle.style.backgroundColor =
                                        "red";
                                    rotationHandle.style.top = "-12px";
                                    rotationHandle.style.left = "50%";
                                    rotationHandle.style.transform = `translateX(-50%) scale(${
                                        1 / sc
                                    })`;
                                    rotationHandle.style.cursor = "grab";
                                    rotationHandle.addEventListener(
                                        "mousedown",
                                        onPreviewRotationMouseDown
                                    );
                                    circleEl.appendChild(rotationHandle);

                                    // 네 꼭지점에 크기 조절 핸들 (6px×6px, 반대 스케일 적용)
                                    const corners = [
                                        {
                                            pos: "top-left",
                                            style: {
                                                top: "-6px",
                                                left: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                        {
                                            pos: "top-right",
                                            style: {
                                                top: "-6px",
                                                right: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-left",
                                            style: {
                                                bottom: "-6px",
                                                left: "-6px",
                                                cursor: "nesw-resize",
                                            },
                                        },
                                        {
                                            pos: "bottom-right",
                                            style: {
                                                bottom: "-6px",
                                                right: "-6px",
                                                cursor: "nwse-resize",
                                            },
                                        },
                                    ];
                                    corners.forEach((corner) => {
                                        const scaleHandle =
                                            document.createElement("div");
                                        scaleHandle.className = "scale-handle";
                                        scaleHandle.setAttribute(
                                            "data-handle",
                                            "scale"
                                        );
                                        scaleHandle.style.position = "absolute";
                                        scaleHandle.style.width = "12px";
                                        scaleHandle.style.height = "12px";
                                        scaleHandle.style.backgroundColor =
                                            "blue";
                                        for (const key in corner.style) {
                                            scaleHandle.style[key] =
                                                corner.style[key];
                                        }
                                        scaleHandle.style.transform = `scale(${
                                            1 / sc
                                        })`;
                                        scaleHandle.addEventListener(
                                            "mousedown",
                                            onPreviewScaleMouseDown
                                        );
                                        circleEl.appendChild(scaleHandle);
                                    });
                                }

                                previewContent.appendChild(circleEl);
                            }
                        }
                    });
                }

                function getValueAtTime(kframes, localT, dur, ease) {
                    if (!kframes || kframes.length === 0) return 0;
                    kframes.sort((a, b) => a.time - b.time);
                    if (localT < kframes[0].time) return kframes[0].value;
                    if (localT > kframes[kframes.length - 1].time)
                        return kframes[kframes.length - 1].value;
                    for (let i = 0; i < kframes.length - 1; i++) {
                        const k1 = kframes[i],
                            k2 = kframes[i + 1];
                        if (localT >= k1.time && localT <= k2.time) {
                            const alpha =
                                (localT - k1.time) / (k2.time - k1.time);
                            const eased = applyEase(alpha, ease);
                            return k1.value + (k2.value - k1.value) * eased;
                        }
                    }
                    return kframes[kframes.length - 1].value;
                }

                function applyEase(alpha, ease) {
                    switch (ease) {
                        case "easeIn":
                            return 1 - (1 - alpha) * (1 - alpha);
                        case "easeOut":
                            return alpha * alpha;
                        case "easeInOut":
                            return -(Math.cos(Math.PI * alpha) - 1) / 2;
                        default:
                            return alpha;
                    }
                }

                function updateAllGraphs() {
                    if (!selectedClip) return;
                    buildGraph(
                        "graphX",
                        clipsData[selectedClip.id].posX,
                        "posX"
                    );
                    buildGraph(
                        "graphY",
                        clipsData[selectedClip.id].posY,
                        "posY"
                    );
                    buildGraph(
                        "graphScale",
                        clipsData[selectedClip.id].scale,
                        "scale"
                    );
                    buildGraph(
                        "graphRotation",
                        clipsData[selectedClip.id].rotation,
                        "rotation"
                    );
                }

                function buildGraph(gid, kframes, prop) {
                    const container = document.getElementById(gid);
                    const svg = container.querySelector(".graph-line");
                    if (!kframes || kframes.length < 2) {
                        svg.innerHTML = "";
                        container
                            .querySelectorAll(".graph-point, .graph-label")
                            .forEach((pt) => pt.remove());
                        return;
                    }
                    kframes.sort((a, b) => a.time - b.time);
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    const pathData = buildPathData(kframes, w, h, prop);
                    svg.innerHTML = `<path d="${pathData}" stroke="#55aaff" fill="none" stroke-width="2"></path>`;
                    container
                        .querySelectorAll(".graph-point, .graph-label")
                        .forEach((pt) => pt.remove());
                    for (let i = 0; i < kframes.length; i++) {
                        const kf = kframes[i];
                        const { x, y } = kfToXY(
                            kf.time,
                            kf.value,
                            w,
                            h,
                            prop,
                            selectedClip
                        );
                        const point = document.createElement("div");
                        point.className = "graph-point";
                        if (kf.lockTime) point.classList.add("lock-time");
                        point.style.left = x + "px";
                        point.style.top = y + "px";
                        point.addEventListener("mousedown", (e) => {
                            e.stopPropagation();
                            _graphDragInfo = { kframes, index: i, prop };
                            if (kf.lockTime) {
                                _graphDragInfo.lockTime = true;
                            }
                            document.body.classList.add("no-select");
                            document.addEventListener(
                                "mousemove",
                                onGraphDragging
                            );
                            document.addEventListener(
                                "mouseup",
                                onGraphDragEnd
                            );
                        });
                        point.addEventListener("contextmenu", (e) => {
                            e.preventDefault();
                            showGraphPointMenu(e, container, kframes, i, prop);
                        });
                        container.appendChild(point);
                        const label = document.createElement("div");
                        label.className = "graph-label";
                        label.textContent = kf.value.toFixed(1);
                        let labelX = x + 5;
                        let labelY = y - 15;
                        labelX = clamp(labelX, 0, w - 30);
                        labelY = clamp(labelY, 0, h - 15);
                        label.style.left = labelX + "px";
                        label.style.top = labelY + "px";
                        label.addEventListener("dblclick", function (e) {
                            e.stopPropagation();
                            editGraphLabel(label, kf, prop);
                        });
                        container.appendChild(label);
                    }
                }

                function buildPathData(kframes, w, h, prop) {
                    if (kframes.length < 2) return "";
                    kframes.sort((a, b) => a.time - b.time);
                    const cdata = clipsData[selectedClip.id];
                    const ease = cdata.ease[prop] || "linear";
                    const dur = cdata.endTime - cdata.startTime;
                    let d = "";
                    let firstPoint = true;
                    const samplesPerSegment = 20;
                    for (let i = 0; i < kframes.length - 1; i++) {
                        const k1 = kframes[i];
                        const k2 = kframes[i + 1];
                        for (let j = 0; j <= samplesPerSegment; j++) {
                            const t =
                                k1.time +
                                (k2.time - k1.time) * (j / samplesPerSegment);
                            let alpha = (t - k1.time) / (k2.time - k1.time);
                            let easedAlpha = applyEase(alpha, ease);
                            let interpolatedValue =
                                k1.value + (k2.value - k1.value) * easedAlpha;
                            let x = (t / dur) * w;
                            let y;
                            if (prop === "posX") {
                                interpolatedValue = clamp(
                                    interpolatedValue,
                                    -240,
                                    240
                                );
                                y = ((240 - interpolatedValue) / 480) * h;
                            } else if (prop === "posY") {
                                interpolatedValue = clamp(
                                    interpolatedValue,
                                    -135,
                                    135
                                );
                                y = ((135 - interpolatedValue) / 270) * h;
                            } else if (prop === "scale") {
                                interpolatedValue = clamp(
                                    interpolatedValue,
                                    20,
                                    500
                                );
                                y = ((500 - interpolatedValue) / 480) * h;
                            } else if (prop === "rotation") {
                                interpolatedValue = clamp(
                                    interpolatedValue,
                                    -360,
                                    360
                                );
                                y = ((360 - interpolatedValue) / 720) * h;
                            } else {
                                y = h / 2;
                            }
                            y = clamp(y, 0, h);
                            if (firstPoint) {
                                d += `M ${x} ${y}`;
                                firstPoint = false;
                            } else {
                                d += ` L ${x} ${y}`;
                            }
                        }
                    }
                    return d;
                }

                function kfToXY(time, value, w, h, prop, clipDom) {
                    const cdata = clipsData[clipDom.id];
                    const dur = cdata.endTime - cdata.startTime;
                    if (dur <= 0) return { x: 0, y: h / 2 };
                    let xx = (time / dur) * w;
                    let yy;
                    if (prop === "posX") {
                        value = clamp(value, -240, 240);
                        yy = ((240 - value) / 480) * h;
                    } else if (prop === "posY") {
                        value = clamp(value, -135, 135);
                        yy = ((135 - value) / 270) * h;
                    } else if (prop === "scale") {
                        value = clamp(value, 20, 500);
                        yy = ((500 - value) / 480) * h;
                    } else if (prop === "rotation") {
                        value = clamp(value, -360, 360);
                        yy = ((360 - value) / 720) * h;
                    } else {
                        yy = h / 2;
                    }
                    return { x: xx, y: yy };
                }

                function onGraphDragging(e) {
                    if (!_graphDragInfo || !selectedClip) return;
                    const container = getGraphContainer(_graphDragInfo.prop);
                    const cdata = clipsData[selectedClip.id];
                    const rect = container.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    let y = e.clientY - rect.top;
                    x = clamp(x, 0, rect.width);
                    y = clamp(y, 0, rect.height);
                    const dur = cdata.endTime - cdata.startTime;
                    const kf = _graphDragInfo.kframes[_graphDragInfo.index];
                    if (!_graphDragInfo.lockTime) {
                        kf.time = (x / rect.width) * dur;
                        kf.time = clamp(kf.time, 0, dur);
                    }
                    let computedVal;
                    if (_graphDragInfo.prop === "posX") {
                        const centerY = rect.height / 2;
                        let val = (centerY - y) * (240 / centerY);
                        computedVal = clamp(
                            parseFloat(val.toFixed(1)),
                            -240,
                            240
                        );
                    } else if (_graphDragInfo.prop === "posY") {
                        const centerY = rect.height / 2;
                        let val = (centerY - y) * (135 / centerY);
                        computedVal = clamp(
                            parseFloat(val.toFixed(1)),
                            -135,
                            135
                        );
                    } else if (_graphDragInfo.prop === "scale") {
                        computedVal = clamp(
                            parseFloat(
                                (500 - (480 / rect.height) * y).toFixed(1)
                            ),
                            20,
                            500
                        );
                    } else if (_graphDragInfo.prop === "rotation") {
                        computedVal = clamp(
                            parseFloat(
                                (360 - (720 / rect.height) * y).toFixed(1)
                            ),
                            -360,
                            360
                        );
                    } else {
                        const centerY = rect.height / 2;
                        let val = (centerY - y) * (200 / centerY);
                        computedVal = parseFloat(val.toFixed(1));
                    }
                    kf.value = computedVal;
                    updateAllGraphs();
                    updatePreview(currentTime);
                }

                setInterval(function () {
                    updatePreview(currentTime);
                }, 300);

                function onGraphDragEnd(e) {
                    document.body.classList.remove("no-select");
                    document.removeEventListener("mousemove", onGraphDragging);
                    document.removeEventListener("mouseup", onGraphDragEnd);
                    _graphDragInfo = null;
                }

                function getGraphContainer(prop) {
                    switch (prop) {
                        case "posX":
                            return document.getElementById("graphX");
                        case "posY":
                            return document.getElementById("graphY");
                        case "scale":
                            return document.getElementById("graphScale");
                        case "rotation":
                            return document.getElementById("graphRotation");
                    }
                }

                function showGraphPointMenu(e, container, kframes, idx, prop) {
                    const menu = document.createElement("div");
                    menu.className = "graph-context-menu";
                    menu.style.display = "block";
                    menu.style.left = e.pageX + "px";
                    menu.style.top = e.pageY + "px";
                    const del = document.createElement("div");
                    del.innerText = "키프레임 삭제";
                    del.addEventListener("click", () => {
                        if (!kframes[idx].lockTime) {
                            kframes.splice(idx, 1);
                        }
                        document.body.removeChild(menu);
                        updateAllGraphs();
                        updatePreview(currentTime);
                    });
                    menu.appendChild(del);
                    document.body.appendChild(menu);
                    document.addEventListener(
                        "click",
                        () => {
                            if (document.body.contains(menu)) {
                                document.body.removeChild(menu);
                            }
                        },
                        { once: true }
                    );
                }

                function editGraphLabel(label, kf, prop) {
                    const input = document.createElement("input");
                    input.type = "number";
                    input.value = kf.value;
                    input.style.position = "absolute";
                    input.style.left = label.style.left;
                    input.style.top = label.style.top;
                    input.style.width = "40px";
                    input.style.fontSize = "10px";
                    input.style.padding = "2px";
                    input.style.zIndex = 10000;
                    label.parentNode.appendChild(input);
                    input.focus();
                    input.addEventListener("blur", function () {
                        const newVal = parseFloat(input.value);
                        if (!isNaN(newVal)) {
                            if (prop === "posX") {
                                kf.value = clamp(newVal, -240, 240);
                            } else if (prop === "posY") {
                                kf.value = clamp(newVal, -135, 135);
                            } else if (prop === "scale") {
                                kf.value = clamp(newVal, 20, 500);
                            } else if (prop === "rotation") {
                                kf.value = clamp(newVal, -360, 360);
                            } else {
                                kf.value = newVal;
                            }
                            updateAllGraphs();
                            updatePreview(currentTime);
                        }
                        input.parentNode.removeChild(input);
                    });
                    input.addEventListener("keydown", function (e) {
                        if (e.key === "Enter") {
                            input.blur();
                        }
                    });
                }

                function onTogglePlay() {
                    if (isPlaying) {
                        onPause();
                    } else {
                        onPlay();
                    }
                    updateToggleButtonIcon();
                }

                function updateToggleButtonIcon() {
                    const btn = document.getElementById("togglePlayBtn");
                    if (isPlaying) {
                        btn.title = "일시정지";
                        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="6" y="4" width="4" height="16"></rect>
                            <rect x="14" y="4" width="4" height="16"></rect>
                          </svg>`;
                    } else {
                        btn.title = "재생";
                        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                          </svg>`;
                    }
                }

                function onPlay() {
                    if (!isPlaying) {
                        isPlaying = true;
                        lastTimestamp = performance.now();
                        requestAnimationFrame(updateLoop);
                        if (bgAudio) {
                            bgAudio.currentTime = currentTime;
                            bgAudio.play();
                        }
                    }
                }

                function onPause() {
                    isPlaying = false;
                    if (bgAudio) {
                        bgAudio.pause();
                    }
                }

                function onRewind() {
                    currentTime = 0;
                    updatePreview(currentTime);
                    document.getElementById("currentTimeLabel").innerText =
                        currentTime.toFixed(2);
                    updateTimeIndicator();
                    if (bgAudio) {
                        bgAudio.currentTime = 0;
                    }
                }

                setInterval(function () {
                    updatePreview(currentTime);
                }, 300);

                function updateLoop(timestamp) {
                    if (!isPlaying) return;
                    const delta = (timestamp - lastTimestamp) / 1000;
                    lastTimestamp = timestamp;
                    currentTime += delta;
                    if (currentTime > totalDuration) {
                        currentTime = totalDuration;
                        isPlaying = false;
                    }
                    document.getElementById("currentTimeLabel").innerText =
                        currentTime.toFixed(2);
                    updatePreview(currentTime);
                    updateTimeIndicator();
                    if (bgAudio && !bgAudio.paused) {
                        if (Math.abs(bgAudio.currentTime - currentTime) > 0.1) {
                            bgAudio.currentTime = currentTime;
                        }
                    }
                    if (isPlaying) requestAnimationFrame(updateLoop);
                }

                // ── 엔트리 내보내기 기능 ──
                function exportEntryProject() {
                    let lines = [];
                    let bgColor =
                        document.getElementById("previewBgColor").value;
                    lines.push(bgColor);
                    const shapeColorNameMap = {
                        "#FF0000": "빨강",
                        "#FFA500": "주황",
                        "#FFFF00": "노랑",
                        "#008000": "초록",
                        "#0000FF": "파랑",
                        "#800080": "보라",
                    };
                    let clipsArray = Object.values(clipsData);
                    clipsArray.sort((a, b) => b.trackIndex - a.trackIndex);
                    clipsArray.forEach((clip) => {
                        if (clip.type === "text") {
                            let line =
                                "텍스트" +
                                "|" +
                                clip.content +
                                "|" +
                                clip.fontFamily +
                                "|" +
                                clip.bold +
                                "|" +
                                clip.italic +
                                "|" +
                                clip.underline +
                                "|" +
                                clip.strikethrough +
                                "|" +
                                clip.textColor +
                                "|" +
                                clip.backgroundColor +
                                "|" +
                                Math.round(clip.startTime * 100000) / 100000 +
                                "|" +
                                Math.round(clip.endTime * 100000) / 100000 +
                                "|" +
                                clip.ease.posX +
                                "|" +
                                clip.posX[0].value +
                                "|" +
                                clip.posX[clip.posX.length - 1].value +
                                "|" +
                                clip.ease.posY +
                                "|" +
                                clip.posY[0].value +
                                "|" +
                                clip.posY[clip.posY.length - 1].value +
                                "|" +
                                clip.ease.scale +
                                "|" +
                                clip.scale[0].value +
                                "|" +
                                clip.scale[clip.scale.length - 1].value +
                                "|" +
                                clip.ease.rotation +
                                "|" +
                                clip.rotation[0].value +
                                "|" +
                                clip.rotation[clip.rotation.length - 1].value;
                            lines.push(line);
                        } else if (clip.type === "rectangle") {
                            let colorName =
                                shapeColorNameMap[clip.shapeColor] ||
                                clip.shapeColor;
                            let line =
                                "사각형" +
                                "|" +
                                colorName +
                                "|" +
                                Math.round(clip.startTime * 100000) / 100000 +
                                "|" +
                                Math.round(clip.endTime * 100000) / 100000 +
                                "|" +
                                clip.ease.posX +
                                "|" +
                                clip.posX[0].value +
                                "|" +
                                clip.posX[clip.posX.length - 1].value +
                                "|" +
                                clip.ease.posY +
                                "|" +
                                clip.posY[0].value +
                                "|" +
                                clip.posY[clip.posY.length - 1].value +
                                "|" +
                                clip.ease.scale +
                                "|" +
                                clip.scale[0].value +
                                "|" +
                                clip.scale[clip.scale.length - 1].value +
                                "|" +
                                clip.ease.rotation +
                                "|" +
                                clip.rotation[0].value +
                                "|" +
                                clip.rotation[clip.rotation.length - 1].value;
                            lines.push(line);
                        } else if (clip.type === "circle") {
                            let colorName =
                                shapeColorNameMap[clip.shapeColor] ||
                                clip.shapeColor;
                            let line =
                                "원" +
                                "|" +
                                colorName +
                                "|" +
                                Math.round(clip.startTime * 100000) / 100000 +
                                "|" +
                                Math.round(clip.endTime * 100000) / 100000 +
                                "|" +
                                clip.ease.posX +
                                "|" +
                                clip.posX[0].value +
                                "|" +
                                clip.posX[clip.posX.length - 1].value +
                                "|" +
                                clip.ease.posY +
                                "|" +
                                clip.posY[0].value +
                                "|" +
                                clip.posY[clip.posY.length - 1].value +
                                "|" +
                                clip.ease.scale +
                                "|" +
                                clip.scale[0].value +
                                "|" +
                                clip.scale[clip.scale.length - 1].value +
                                "|" +
                                clip.ease.rotation +
                                "|" +
                                clip.rotation[0].value +
                                "|" +
                                clip.rotation[clip.rotation.length - 1].value;
                            lines.push(line);
                        } else if (clip.type === "fill") {
                            let line =
                                "채우기" +
                                "|" +
                                Math.round(clip.startTime * 100000) / 100000 +
                                "|" +
                                Math.round(clip.endTime * 100000) / 100000 +
                                "|" +
                                clip.fillColor;
                            lines.push(line);
                        }
                    });
                    let output = lines.join("\n");
                    document.getElementById("exportCode").textContent = output;
                }

                // ── 엔트리 불러오기 기능 ──
                function importEntryProject(importText) {
                    clipsData = {};
                    trackList = [];
                    const timelineBody =
                        document.getElementById("timelineBody");
                    timelineBody
                        .querySelectorAll(".track")
                        .forEach((track) => track.remove());
                    currentTime = 0;
                    updateTimeIndicator();

                    const lines = importText
                        .split("\n")
                        .map((line) => line.trim())
                        .filter((line) => line !== "");
                    if (lines.length === 0) return;

                    const bgColor = lines[0];
                    document.getElementById("previewBgColor").value = bgColor;
                    document.querySelector(
                        "#preview .preview-content"
                    ).style.backgroundColor = bgColor;

                    let maxEndTime = 0;
                    for (let i = lines.length - 1; i > 0; i--) {
                        const tokens = lines[i].split("|");
                        if (tokens.length === 0) continue;
                        let clipType = tokens[0];
                        let clipData = {};
                        let startTime, endTime;
                        let type;
                        if (clipType === "텍스트") {
                            if (tokens.length < 23) continue;
                            type = "text";
                            startTime = parseFloat(tokens[9]);
                            endTime = parseFloat(tokens[10]);
                            clipData = {
                                id: "",
                                type: "text",
                                content: tokens[1],
                                fontFamily: tokens[2],
                                bold: tokens[3] === "true",
                                italic: tokens[4] === "true",
                                underline: tokens[5] === "true",
                                strikethrough: tokens[6] === "true",
                                textColor: tokens[7],
                                backgroundColor: tokens[8],
                                startTime: startTime,
                                endTime: endTime,
                                ease: {
                                    posX: tokens[11],
                                    posY: tokens[14],
                                    scale: tokens[17],
                                    rotation: tokens[20],
                                },
                                posX: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[12]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[13]),
                                        lockTime: true,
                                    },
                                ],
                                posY: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[15]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[16]),
                                        lockTime: true,
                                    },
                                ],
                                scale: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[18]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[19]),
                                        lockTime: true,
                                    },
                                ],
                                rotation: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[21]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[22]),
                                        lockTime: true,
                                    },
                                ],
                            };
                        } else if (clipType === "사각형" || clipType === "원") {
                            if (tokens.length < 16) continue;
                            type =
                                clipType === "사각형" ? "rectangle" : "circle";
                            startTime = parseFloat(tokens[2]);
                            endTime = parseFloat(tokens[3]);
                            const colorNameToHex = {
                                빨강: "#FF0000",
                                주황: "#FFA500",
                                노랑: "#FFFF00",
                                초록: "#008000",
                                파랑: "#0000FF",
                                보라: "#800080",
                            };
                            clipData = {
                                id: "",
                                type: type,
                                startTime: startTime,
                                endTime: endTime,
                                shapeColor:
                                    colorNameToHex[tokens[1]] || tokens[1],
                                ease: {
                                    posX: tokens[4],
                                    posY: tokens[7],
                                    scale: tokens[10],
                                    rotation: tokens[13],
                                },
                                posX: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[5]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[6]),
                                        lockTime: true,
                                    },
                                ],
                                posY: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[8]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[9]),
                                        lockTime: true,
                                    },
                                ],
                                scale: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[11]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[12]),
                                        lockTime: true,
                                    },
                                ],
                                rotation: [
                                    {
                                        time: 0,
                                        value: parseFloat(tokens[14]),
                                        lockTime: true,
                                    },
                                    {
                                        time: endTime - startTime,
                                        value: parseFloat(tokens[15]),
                                        lockTime: true,
                                    },
                                ],
                            };
                        } else if (clipType === "채우기") {
                            if (tokens.length < 4) continue;
                            type = "fill";
                            startTime = parseFloat(tokens[1]);
                            endTime = parseFloat(tokens[2]);
                            clipData = {
                                id: "",
                                type: "fill",
                                startTime: startTime,
                                endTime: endTime,
                                fillColor: tokens[3],
                            };
                        } else {
                            continue;
                        }
                        maxEndTime = Math.max(maxEndTime, endTime);
                        let trackNum = findAvailableTrack(startTime, endTime);
                        if (!trackNum) {
                            createTrack();
                            trackNum = trackList.length;
                        }
                        let clipId =
                            "clip-" + Math.random().toString(36).substr(2, 9);
                        clipData.id = clipId;
                        clipData.trackIndex = trackNum;
                        let clipDom = createClipDom(
                            clipId,
                            startTime,
                            endTime,
                            type
                        );
                        trackList[trackNum - 1].appendChild(clipDom);
                        clipsData[clipId] = clipData;
                    }
                    if (maxEndTime > totalDuration) {
                        totalDuration = maxEndTime;
                        document.querySelectorAll(".track").forEach((track) => {
                            track.style.width =
                                totalDuration * PIXELS_PER_SECOND + "px";
                        });
                    }
                    updatePreview(currentTime);
                }

                const resizer = document.getElementById("resizer");
                const rightPanel = document.querySelector(".right-panel");
                const mainContainer = document.querySelector(".main-container");
                let isResizing = false;
                resizer.addEventListener("mousedown", (e) => {
                    isResizing = true;
                    e.preventDefault();
                });
                document.addEventListener("mousemove", (e) => {
                    if (!isResizing) return;
                    const containerRect = mainContainer.getBoundingClientRect();
                    let newWidth = containerRect.right - e.clientX;
                    newWidth = Math.max(newWidth, 200);
                    newWidth = Math.min(newWidth, 600);
                    rightPanel.style.width = newWidth + "px";
                });
                document.addEventListener("mouseup", () => {
                    isResizing = false;
                });

                function toggleStyle(property) {
                    if (!selectedClip) return;
                    const cdata = clipsData[selectedClip.id];
                    cdata[property] = !cdata[property];
                    updateStyleButtons();
                    updatePreview(currentTime);
                }

                // 드래그 시 no-select 적용
                document.addEventListener("mousedown", function (e) {
                    if (e.target.closest(".clip, .graph-point")) {
                        document.body.classList.add("no-select");
                    }
                });
                document.addEventListener("mouseup", function (e) {
                    document.body.classList.remove("no-select");
                });

                // 타임라인 빈 영역 클릭 시 선택 해제
                document
                    .getElementById("timelineBody")
                    .addEventListener("click", function (e) {
                        if (!e.target.closest(".clip")) {
                            deselectClip();
                        }
                    });

                // 타임 인디케이터 드래그 이벤트 (현재시간 빨간선)
                document
                    .getElementById("timeIndicator")
                    .addEventListener("mousedown", function (e) {
                        draggingTimeIndicator = true;
                        timeIndicatorOffsetX = e.offsetX;
                        e.stopPropagation();
                    });
                document.addEventListener("mousemove", function (e) {
                    if (draggingTimeIndicator) {
                        const timelineBody =
                            document.getElementById("timelineBody");
                        const rect = timelineBody.getBoundingClientRect();
                        // scrollLeft를 더해 컨텐츠 내의 정확한 좌표를 계산
                        let newX =
                            e.clientX -
                            rect.left +
                            timelineBody.scrollLeft -
                            timeIndicatorOffsetX;
                        // 전체 컨텐츠 너비(timelineBody.scrollWidth)를 기준으로 clmap 처리
                        newX = clamp(newX, 0, timelineBody.scrollWidth);
                        currentTime = newX / PIXELS_PER_SECOND;
                        updateTimeIndicator();
                        document.getElementById("currentTimeLabel").innerText =
                            currentTime.toFixed(2);
                        updatePreview(currentTime);
                    }
                });
                document.addEventListener("mouseup", function () {
                    draggingTimeIndicator = false;
                });

                window.addEventListener("DOMContentLoaded", () => {
                    // 타임라인 배경(빈 영역) 우클릭 시 붙여넣기 메뉴 표시
                    document
                        .getElementById("timelineBody")
                        .addEventListener("contextmenu", function (e) {
                            // 이미 클립 요소 위에서 우클릭한 경우(클립의 컨텍스트 메뉴가 있으면) 무시
                            if (e.target.closest(".clip")) return;

                            e.preventDefault();

                            // 기존 타임라인 컨텍스트 메뉴가 있다면 제거
                            let existingMenu = document.getElementById(
                                "timelineContextMenu"
                            );
                            if (existingMenu) {
                                existingMenu.remove();
                            }

                            // 타임라인 컨텍스트 메뉴 생성 (스타일은 기존 clip-context-menu와 유사하게)
                            let menu = document.createElement("div");
                            menu.id = "timelineContextMenu";
                            menu.style.position = "absolute";
                            menu.style.backgroundColor = "#444";
                            menu.style.border = "1px solid #666";
                            menu.style.padding = "4px";
                            menu.style.zIndex = "9999";

                            // 복사된 클립 데이터(copiedClipData)가 있으면 붙여넣기 옵션 추가
                            if (copiedClipData) {
                                let pasteOption = document.createElement("div");
                                pasteOption.innerText = "붙여넣기";
                                pasteOption.style.padding = "4px 12px";
                                pasteOption.style.cursor = "pointer";
                                pasteOption.addEventListener(
                                    "click",
                                    function () {
                                        // 타임라인의 클릭 위치에 해당하는 시간 계산
                                        const timelineBody =
                                            document.getElementById(
                                                "timelineBody"
                                            );
                                        const rect =
                                            timelineBody.getBoundingClientRect();
                                        // timelineBody는 스크롤이 있을 수 있으므로 scrollLeft를 고려
                                        const clickX =
                                            e.clientX -
                                            rect.left +
                                            timelineBody.scrollLeft;
                                        let pasteTime =
                                            clickX / PIXELS_PER_SECOND; // PIXELS_PER_SECOND는 기존에 정의된 시간-픽셀 변환 상수

                                        // 복사한 클립 데이터를 deep copy하여 새 클립 데이터 생성
                                        let newId =
                                            "clip-" +
                                            Math.random()
                                                .toString(36)
                                                .substr(2, 9);
                                        let newClipData = JSON.parse(
                                            JSON.stringify(copiedClipData)
                                        );
                                        newClipData.id = newId;
                                        // 원본 클립과 겹치지 않도록 약간의 오프셋(예, 0.5초)을 더합니다.
                                        let offset = 0.5;
                                        let duration =
                                            newClipData.endTime -
                                            newClipData.startTime;
                                        newClipData.startTime =
                                            pasteTime + offset;
                                        newClipData.endTime =
                                            newClipData.startTime + duration;

                                        // 우클릭한 위치가 속한 트랙(요소)이 있다면 해당 트랙에 붙여넣고,
                                        // 없다면 첫 번째 트랙을 사용(없으면 새 트랙 생성)
                                        let targetTrack =
                                            e.target.closest(".track");
                                        if (!targetTrack) {
                                            if (trackList.length > 0) {
                                                targetTrack = trackList[0];
                                                newClipData.trackIndex = 1;
                                            } else {
                                                createTrack();
                                                targetTrack = trackList[0];
                                                newClipData.trackIndex = 1;
                                            }
                                        } else {
                                            newClipData.trackIndex =
                                                trackList.indexOf(targetTrack) +
                                                1;
                                        }

                                        // 새 클립 DOM 생성 후 트랙에 추가
                                        let newClipDom = createClipDom(
                                            newId,
                                            newClipData.startTime,
                                            newClipData.endTime,
                                            newClipData.type
                                        );
                                        targetTrack.appendChild(newClipDom);
                                        clipsData[newId] = newClipData;

                                        // 메뉴 제거
                                        if (document.body.contains(menu)) {
                                            menu.remove();
                                        }
                                    }
                                );
                                menu.appendChild(pasteOption);
                            } else {
                                // 붙여넣기 가능한 클립 데이터가 없으면 안내 문구 표시
                                let noOption = document.createElement("div");
                                noOption.innerText = "붙여넣기 없음";
                                noOption.style.padding = "4px 12px";
                                menu.appendChild(noOption);
                            }

                            // 메뉴 위치를 마우스 우클릭 좌표에 맞춤
                            menu.style.left = e.pageX + "px";
                            menu.style.top = e.pageY + "px";

                            document.body.appendChild(menu);

                            // 다른 곳 클릭 시 메뉴 제거
                            document.addEventListener(
                                "click",
                                function handler() {
                                    if (document.body.contains(menu)) {
                                        menu.remove();
                                    }
                                },
                                { once: true }
                            );
                        });
                    document
                        .getElementById("addTextBtn")
                        .addEventListener("click", onAddText);
                    document
                        .getElementById("addRectBtn")
                        .addEventListener("click", onAddRect);
                    document
                        .getElementById("addCircleBtn")
                        .addEventListener("click", onAddCircle);
                    document
                        .getElementById("addFillBtn")
                        .addEventListener("click", onAddFill);
                    document
                        .getElementById("addTrackBtn")
                        .addEventListener("click", () => {
                            createTrack();
                        });
                    document
                        .getElementById("deleteTrackBtn")
                        .addEventListener("click", () => {
                            if (trackList.length > 0) {
                                const track = trackList.pop();
                                const clipsInTrack =
                                    track.querySelectorAll(".clip");
                                clipsInTrack.forEach((clip) => {
                                    delete clipsData[clip.id];
                                });
                                track.remove();
                            }
                        });
                    document
                        .getElementById("rewindBtn")
                        .addEventListener("click", onRewind);
                    document
                        .getElementById("togglePlayBtn")
                        .addEventListener("click", onTogglePlay);
                    document
                        .getElementById("textContent")
                        .addEventListener("input", onPropChange);
                    document
                        .getElementById("startTime")
                        .addEventListener("input", onPropChange);
                    document
                        .getElementById("endTime")
                        .addEventListener("input", onPropChange);
                    document
                        .getElementById("easePosX")
                        .addEventListener("change", onEaseChange);
                    document
                        .getElementById("easePosY")
                        .addEventListener("change", onEaseChange);
                    document
                        .getElementById("easeScale")
                        .addEventListener("change", onEaseChange);
                    document
                        .getElementById("easeRotation")
                        .addEventListener("change", onEaseChange);
                    document
                        .getElementById("fontFamily")
                        .addEventListener("change", onFontFamilyChange);
                    document
                        .getElementById("textColor")
                        .addEventListener("input", onPropChange);
                    document
                        .getElementById("bgColor")
                        .addEventListener("input", onPropChange);
                    // 배경 투명 체크박스 이벤트
                    document
                        .getElementById("bgTransparent")
                        .addEventListener("change", onPropChange);
                    document
                        .getElementById("boldBtn")
                        .addEventListener("click", () => {
                            toggleStyle("bold");
                        });
                    document
                        .getElementById("italicBtn")
                        .addEventListener("click", () => {
                            toggleStyle("italic");
                        });
                    document
                        .getElementById("underlineBtn")
                        .addEventListener("click", () => {
                            toggleStyle("underline");
                        });
                    document
                        .getElementById("strikethroughBtn")
                        .addEventListener("click", () => {
                            toggleStyle("strikethrough");
                        });
                    document
                        .getElementById("trackDelete")
                        .addEventListener("click", onTrackDelete);
                    document
                        .getElementById("trackCopy")
                        .addEventListener("click", onTrackCopy);
                    document
                        .getElementById("trackPaste")
                        .addEventListener("click", onTrackPaste);
                    document
                        .getElementById("shapeColor")
                        .addEventListener("change", onShapeColorChange);
                    // 채우기 색상 변경 이벤트 추가
                    document
                        .getElementById("fillColor")
                        .addEventListener("input", onPropChange);
                    document
                        .getElementById("fillStartTime")
                        .addEventListener("input", onFillTimeChange);
                    document
                        .getElementById("fillEndTime")
                        .addEventListener("input", onFillTimeChange);
                    document
                        .getElementById("bgMusicAdd")
                        .addEventListener("click", function (e) {
                            document.getElementById("bgMusicInput").click();
                        });
                    const previewBgInput =
                        document.getElementById("previewBgColor");
                    previewBgInput.addEventListener("input", function (e) {
                        document.querySelector(
                            "#preview .preview-content"
                        ).style.backgroundColor = e.target.value;
                    });
                    document
                        .getElementById("bgMusicInput")
                        .addEventListener("change", function (e) {
                            const file = e.target.files[0];
                            if (file) {
                                if (bgAudio) {
                                    bgAudio.pause();
                                }
                                bgAudio = new Audio(URL.createObjectURL(file));
                                bgAudioBlob = file;
                                bgAudio.load();
                                bgAudio.currentTime = currentTime;
                                if (isPlaying) {
                                    bgAudio.play();
                                }
                                document.getElementById(
                                    "bgMusicFileName"
                                ).textContent = file.name;
                            }
                        });
                    document
                        .getElementById("bgVolumeControl")
                        .addEventListener("input", function (e) {
                            if (bgAudio) {
                                bgAudio.volume = e.target.value;
                            }
                        });
                    document
                        .getElementById("exportEntry")
                        .addEventListener("click", function (e) {
                            e.preventDefault();
                            exportEntryProject();
                            document.getElementById(
                                "exportModal"
                            ).style.display = "block";
                        });
                    document
                        .getElementById("copyExportCode")
                        .addEventListener("click", function () {
                            const exportText =
                                document.getElementById(
                                    "exportCode"
                                ).textContent;
                            navigator.clipboard
                                .writeText(exportText)
                                .then(() => {
                                    alert("내보내기 텍스트가 복사되었습니다.");
                                })
                                .catch(() => {
                                    alert("복사에 실패했습니다.");
                                });
                        });
                    document
                        .getElementById("exportFile")
                        .addEventListener("click", async function () {
                            let typoArrayData = [];
                            document
                                .getElementById("exportCode")
                                .textContent.split("\n")
                                .forEach((value) =>
                                    typoArrayData.push({ data: value })
                                );
                            const projectJSON = await fetch(
                                "project.json"
                            ).then((res) => res.json());
                            let audioFileName = Array.from(
                                { length: 32 },
                                () =>
                                    "abcdefghijklmnopqrstuvwxyz0123456789"[
                                        Math.floor(
                                            Math.random() *
                                                "abcdefghijklmnopqrstuvwxyz0123456789"
                                                    .length
                                        )
                                    ]
                            ).join("");
                            projectJSON.variables[19].array = typoArrayData;
                            if (bgAudio != null) {
                                projectJSON.objects[0].sprite.sounds[0].duration =
                                    bgAudio.duration;
                            }
                            projectJSON.objects[0].sprite.sounds[0].filename =
                                audioFileName;
                            projectJSON.objects[0].sprite.sounds[0].fileurl = `temp/${audioFileName.slice(
                                0,
                                2
                            )}/${audioFileName.slice(
                                2,
                                4
                            )}/sound/${audioFileName}.mp3`;
                            let tar = new tarball.TarWriter();
                            tar.addFile(
                                `temp/${audioFileName.slice(
                                    0,
                                    2
                                )}/${audioFileName.slice(
                                    2,
                                    4
                                )}/sound/${audioFileName}.mp3`,
                                new File(
                                    [bgAudioBlob],
                                    `temp/${audioFileName.slice(
                                        0,
                                        2
                                    )}/${audioFileName.slice(
                                        2,
                                        4
                                    )}/sound/${audioFileName}.mp3`
                                )
                            );
                            tar.addFile(
                                "temp/project.json",
                                new File(
                                    [new Blob([JSON.stringify(projectJSON)])],
                                    "temp/project.json"
                                )
                            );
                            const imgData = await fetch("img.zip").then((res) =>
                                res.blob()
                            );
                            const zipData = await new JSZip().loadAsync(
                                imgData
                            );
                            console.log(zipData);
                            for (const [fileName, zipFile] of Object.entries(
                                zipData.files
                            )) {
                                if (!zipFile.dir) {
                                    const fileBlob = await zipFile.async(
                                        "blob"
                                    );
                                    let file = new File([fileBlob], fileName);
                                    console.log(fileName);
                                    tar.addFile("temp" + "\\" + fileName, file);
                                }
                            }
                            tar.download("project.ent");
                        });
                    document
                        .querySelector(".preview-content")
                        .addEventListener("mousedown", function (e) {
                            if (!e.target.closest("[data-clip-id]")) {
                                deselectClip();
                            }
                        });

                    document
                        .querySelector("#exportModal .close-modal")
                        .addEventListener("click", function () {
                            document.getElementById(
                                "exportModal"
                            ).style.display = "none";
                        });
                    window.addEventListener("click", function (e) {
                        if (
                            e.target == document.getElementById("exportModal")
                        ) {
                            document.getElementById(
                                "exportModal"
                            ).style.display = "none";
                        }
                    });
                    document
                        .getElementById("importEntry")
                        .addEventListener("click", function (e) {
                            e.preventDefault();
                            document.getElementById(
                                "importModal"
                            ).style.display = "block";
                        });
                    document
                        .getElementById("importEntryBtn")
                        .addEventListener("click", function () {
                            const importText =
                                document.getElementById("importCode").value;
                            importEntryProject(importText);
                            document.getElementById(
                                "importModal"
                            ).style.display = "none";
                        });
                    document
                        .querySelector(".import-close-modal")
                        .addEventListener("click", function () {
                            document.getElementById(
                                "importModal"
                            ).style.display = "none";
                        });
                    window.addEventListener("click", function (e) {
                        if (
                            e.target == document.getElementById("importModal")
                        ) {
                            document.getElementById(
                                "importModal"
                            ).style.display = "none";
                        }
                    });
                });
            })();
        </script>
    </body>
</html>
